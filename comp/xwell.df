C  XWELL.F - WELL ROUTINES FOR COMPOSITIONAL CALCULATIONS
C  COMPOSITIONAL IMPEC MODEL

C  ROUTINES IN THIS MODULE:

C  SUBROUTINE XWSTART(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                     KL2,KEYOUT,NBLK,PV)
C  SUBROUTINE XWSTAB(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                    KL2,KEYOUT,NBLK,DMOB,DCFL)
C  SUBROUTINE XWSET(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                   KL2,KEYOUT,NBLK,ICFL)
C  SUBROUTINE XBHP(CHANGE_BHP)
C  SUBROUTINE XRATE
C  SUBROUTINE XWELLCALC
C  SUBROUTINE XWELVAL1(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                      KL2,KEYOUT,NBLK,TEMPR,MOB,PMD)
C  SUBROUTINE XGET_WPRES
C  SUBROUTINE XGET_ELEVAL
C  SUBROUTINE XPUT_ELEVAL
C  SUBROUTINE XPUT_WELVAL
C  SUBROUTINE XSET_WPRES(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                        KL2,KEYOUT,NBLK,PRES,MDENN,DEPTH,SAT)
C  SUBROUTINE XWELFLOW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                      KL2,KEYOUT,NBLK,DFLOW,RESID)
C  SUBROUTINE XWFLOW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                    KL2,KEYOUT,NBLK,DELC)
C  SUBROUTINE XWELCOND(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                      KL2,KEYOUT,NBLK,SCAL)
C  SUBROUTINE XRATE_INJ1(IFLINIT,NCOMP,NC,NPH,ICINPH,NHC,
C                        NFBUG,SHUT,INPUT_WGRAD,CONC,TEMPR,WELL_COMP,
C                        ELECONS,PCOMP,GRAD,PW,MOB,
C                        WELL_COEF,QLAYER,BHP_CONTROL,PLIMIT,
C                        WELL_RESID,WELL_RATE,DQWELLDWP,DQWELLDRP,
C                        RATE_IN,WELL_CONSTRAINT,NCINPH,WDEPTH,
C                        HCOMP,DEN_IC,NEWT,IOPEN)
C  SUBROUTINE XRATE_INJ2(IFLDPNT,ITAB,NCOMP,NC,NPH,ICINPH,NHC,
C                        NFBUG,SHUT,INPUT_WGRAD,CONC,TWELL,
C                        WKH,PCOMP,DELH,GRAD,PW,TOTAL_MOB,
C                        WELL_COEF,ITER,NCINPH,DEN_IC,NEWT)
C  SUBROUTINE BRENT_ROOT(X,F,XIN1,FIN1,XIN2,FIN2,DEL)
C  SUBROUTINE XRATE_PROD1(SEP_TABLE,NCOMP,NC,NPH,ICINPH,NHC,
C                   NFBUG,SHUT,INPUT_WGRAD,TEMPR,WELL_COMP,
C                   ELECONS,PCOMP,GRAD,PW,MOB,
C                   WELL_COEF,QLAYER,BHP_CONTROL,PLIMIT,
C                   WELL_RESID,WELL_RATE,DQWELLDWP,DQWELLDRP,
C                   RATE_IN,WELL_CONSTRAINT,NSTAGE,LCROSS,
C                   WMOL,NCINPH,IFLINIT,WELL_KVAL,
C                   SEP_TEMP,SEP_PRES,CONVERT_PH,CONVERT_IC,
C                   ITYPE,PMD,WDEPTH,HCOMP,ISEPTYP,NEWT,IOPEN,PHNAM)
C  SUBROUTINE XRATE_PROD2(NCOMP,NC,WELLCON,SHUT,INPUT_WGRAD,WKH,
C                         PCOMP,DELH,GRAD,PW,TOTAL_MOB,WELL_COEF,
C                         LCROSS,WMOL,ITER,QCOMP,NEWT)
C  SUBROUTINE SET_KVAL(NC,NHC,NPH,NCINPH,ICINPH,IFLINIT,SEP_TABLE, 
C                      NFBUG,WELL_KVAL,QCOMP,SEP_PRES,NSTAGE,
C                      SEP_TEMP)
C  SUBROUTINE CALC_CONVERT_PH(NC,NPH,NHC,QCOMP,SEP_PRES,NSTAGE, 
C                  WELL_KVAL,SEP_TABLE,SEP_TEMP,CONVERT_PH,
C                  CONVERT_IC,PHNAM)
C  SUBROUTINE SEP_RR(Z,EK,V,LIQ,XDZ,SBINV,TOLRR,NHC)

C  CODE HISTORY:        

C    THE IPARS TEAM          04/02/1997  FRAMEWORK
C    RICK DEAN               03/12/2001  INITIAL VERSION
C    SUNIL G. THOMAS         09/01/2007  THERMAL AND CO2 APPS

C*********************************************************************
      SUBROUTINE XWSTART(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                   KL2,KEYOUT,NBLK,PV)
C*********************************************************************
 
C  CHECKS INJECTION WELLS FOR SATURATION CHANGES IF WELL RATES CHANGED 
C  CURRENTLY DONE AT START OF EACH TIMESTEP.
C  THIS IS A WORK ROUTINE.
C  INPUT:
C     PV(I,J,K) = PORE VOLUME (REAL*8)

C  INPUT/OUTPUT:
C     DTVAL = TIME STEP SIZE DUE TO STABILITY LIMIT

C*********************************************************************
      IMPLICIT NONE
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xbaldat.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 PV(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,IPH,L,I,J,K
      REAL*8 DELP,Q,EPS,DMIN,QSAVE($MXWELL)
      LOGICAL LCHK,ONCE
      SAVE ONCE,QSAVE
      DATA ONCE/.TRUE./

      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XWSTART, OLD TAG =',MSGTAG($XMODEL+1)

      IF(ONCE) THEN
         DO IW = 1,$MXWELL
            QSAVE(IW) = ZERO
         END DO
         ONCE = .FALSE.
      ENDIF

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

      LCHK = .FALSE.
      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT .OR. WSHUT(IW)) CYCLE
         IF(IWTYPE(IW) >= 0) CYCLE
         IF(BHP_CONTROL(IW) >= 0) THEN
            IF(ABS(RATE_IN(IW)-QSAVE(IW)) > 
     &         TENTH*ABS(RATE_IN(IW)) ) LCHK = .TRUE.
            QSAVE(IW) = RATE_IN(IW)
         ELSE
            IF(ABS(RATE_IN(IW)-QSAVE(IW)) > TENTH) LCHK = .TRUE.
            QSAVE(IW) = WELBHP(IW)
         ENDIF
      END DO

      IF(.NOT.LCHK) RETURN

      EPS = TEN_M10
      DMIN = BIG
      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT .OR. WSHUT(IW)) CYCLE
         IF(IWTYPE(IW) >= 0) CYCLE
         NE = NUMELE(IW)
         DO  L = 1,NE
            IF(LOCWEL(6,L,IW)==MYPRC.AND.LOCWEL(1,L,IW)==NBLK) THEN
               I = LOCWEL(3,L,IW)-IOFF
               J = LOCWEL(4,L,IW)-JOFF
               K = LOCWEL(5,L,IW)-KOFF
               IF(KEYOUT(I,J,K) /= 1) CYCLE
               DELP = CWKH*ELECONS(L,IW)*
     &               (WELBHP(IW) - WPRES(L,IW) 
     &              + WELDEN(IW)*(ELEDEP(L,IW)-WDEPTH(IW))) 
               Q = WMOB(1,L,IW)
               DO IPH = 2,NPH
                  Q = MAX(Q,WMOB(IPH,L,IW))
               END DO
               Q = Q*DELP
               IF(Q > EPS) DMIN = MIN(DMIN,PV(I,J,K)*DSMAX_TARG/Q)

            ENDIF
         END DO   
      END DO

      DTVAL = MIN(DTVAL,DMIN)

      END

C*********************************************************************
      SUBROUTINE XWSTAB(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                  KL2,KEYOUT,NBLK,DMOB,DCFL)
C*********************************************************************
 
C  ADDS CONTRIBUTION OF PRODUCTION WELLS TO STABLITY LIMIT.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*4 DMOB(IDIM,JDIM,KDIM,4),DCFL(IDIM,JDIM,KDIM,6)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,IPH,L,I,J,K
      REAL*8 X,DELP,WATMOB,OILMOB,GASMOB,TMOB
      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XWSTAB, OLD TAG =',MSGTAG($IMODEL+1)

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

      IF(NPH == 3) THEN

C        SET INITIAL VALUES TO ZERO
         DO L = 1,6
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2
            DCFL(I,J,K,L) = SZERO
         END DO
         END DO
         END DO
         END DO
         DO IW = 1,NUMWEL
            IF(MODWEL(IW) /= MODACT) CYCLE
            IF(WSHUT(IW) .OR. IWTYPE(IW) <= 0) CYCLE
            NE = NUMELE(IW)
            DO  L = 1,NE
               IF(LOCWEL(6,L,IW)==MYPRC.AND.LOCWEL(1,L,IW)==NBLK) THEN
                  I = LOCWEL(3,L,IW)-IOFF
                  J = LOCWEL(4,L,IW)-JOFF
                  K = LOCWEL(5,L,IW)-KOFF
                  IF(KEYOUT(I,J,K) /= 1) CYCLE
                  DELP = CWKH*ELECONS(L,IW)*( WPRES(L,IW) - WELBHP(IW) 
     &                 - WELDEN(IW)*(ELEDEP(L,IW)-WDEPTH(IW)) )
                  IF(DELP <= ZERO) CYCLE
                  WATMOB = WMOB(1,L,IW)
                  OILMOB = WMOB(2,L,IW)
                  GASMOB = WMOB(3,L,IW)
                  TMOB = WATMOB+OILMOB+GASMOB
                  IF(TMOB <= ZERO) CYCLE
                  X = DELP/TMOB
                  DCFL(I,J,K,1) = DCFL(I,J,K,1) + X*( (OILMOB+GASMOB)
     &                          * DMOB(I,J,K,1)-WATMOB*DMOB(I,J,K,2))
                  DCFL(I,J,K,2) = DCFL(I,J,K,2) - X* WATMOB * 
     &                          ( DMOB(I,J,K,3)+ DMOB(I,J,K,4) )
                  DCFL(I,J,K,3) = DCFL(I,J,K,3) - X* GASMOB *
     &                          ( DMOB(I,J,K,1) + DMOB(I,J,K,2) )
                  DCFL(I,J,K,4) = DCFL(I,J,K,4) + X*( (WATMOB+OILMOB)
     &                          * DMOB(I,J,K,4)-GASMOB*DMOB(I,J,K,3))
C
                  DCFL(I,J,K,5) = DCFL(I,J,K,5) + OILMOB*DELP
                  DCFL(I,J,K,6) = DCFL(I,J,K,6) + GASMOB*DELP
               ENDIF
            END DO   
         END DO
      ELSEIF(NPH == 2) THEN
         DO K = KL1,KL2
         DO J = JL1V(K),JL2V(K)
         DO I = IL1,IL2
            DCFL(I,J,K,1) = SZERO
            DCFL(I,J,K,2) = SZERO
         END DO
         END DO
         END DO
         DO IW = 1,NUMWEL
            IF(MODWEL(IW) /= MODACT) CYCLE
            IF(WSHUT(IW) .OR. IWTYPE(IW) <= 0) CYCLE
            NE = NUMELE(IW)
            DO  L = 1,NE
               IF(LOCWEL(6,L,IW)==MYPRC.AND.LOCWEL(1,L,IW)==NBLK) THEN
                  I = LOCWEL(3,L,IW)-IOFF
                  J = LOCWEL(4,L,IW)-JOFF
                  K = LOCWEL(5,L,IW)-KOFF
                  IF(KEYOUT(I,J,K) /= 1) CYCLE
                  DELP = CWKH*ELECONS(L,IW)*( WPRES(L,IW) - WELBHP(IW) 
     &                 - WELDEN(IW)*(ELEDEP(L,IW)-WDEPTH(IW)) )
                  IF(DELP <= ZERO) CYCLE
                  WATMOB = WMOB(1,L,IW)
                  OILMOB = WMOB(2,L,IW)
                  TMOB = WATMOB+OILMOB
                  IF(TMOB <= ZERO) CYCLE
                  X = DELP/TMOB
                  DCFL(I,J,K,1) = DCFL(I,J,K,1) + X*(OILMOB
     &                          * DMOB(I,J,K,1)-WATMOB*DMOB(I,J,K,2))
                  DCFL(I,J,K,2) = DCFL(I,J,K,2) + OILMOB*DELP
               ENDIF
            END DO   
         END DO
      ENDIF
      END

C*********************************************************************
      SUBROUTINE XWSET(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                 KL2,KEYOUT,NBLK,ICFL)
C*********************************************************************
 
C  SET STABILITY CHECK VALUE FOR WELL CELLS.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER ICFL(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,L,I,J,K
      IF (LEVELE.AND.BUGKEY(1)) WRITE (NFBUG,*)'PROC',MYPRC,
     &  ' ENTERING SUBROUTINE XWSET, OLD TAG =',MSGTAG($IMODEL+1)

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)
      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT) CYCLE
         NE = NUMELE(IW)
         DO  L = 1,NE
            IF(LOCWEL(6,L,IW)==MYPRC.AND.LOCWEL(1,L,IW)==NBLK) THEN
               I = LOCWEL(3,L,IW)-IOFF
               J = LOCWEL(4,L,IW)-JOFF
               K = LOCWEL(5,L,IW)-KOFF
               IF(KEYOUT(I,J,K) == 1) ICFL(I,J,K) = 1
            ENDIF
         END DO   
      END DO
      END

C*********************************************************************
      SUBROUTINE XBHP(CHANGE_BHP,IFLAG)
C*********************************************************************
 
C  UPDATES WELL PRESSURES
C  SETS CHANGE_BHP IF BOTTOMHOLE PRESSURE LIMIT ENCOUNTERED
C  SETS IFLAG = 1 IF BHP LIMIT ENCOUNTERED

C*********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xcompwel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IFLAG
      REAL*8 CHANGE_BHP
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IC,L,IPH
      REAL*8 X,Y,BHP,OBHP,PLIM

      IFLAG = 0
      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT .OR. NWELPRC(IW) /= MYPRC) CYCLE
         IF(WSHUT(IW)) CYCLE
 
C        UPDATE WELL PRESSURE, CHECK LIMIT
         IF(BHP_CONTROL(IW) == 1) THEN
C           EXPLICIT WELLS
            OBHP = WELBHP(IW)
            IF(LINSYSW(IW) < 1) THEN
               X = RATE_IN(IW)
               DO L = 1,NUMELET(IW)
                  X = X + DQWELLDRP(L,IW) *  
     &           ( WELDEN(IW)*(ELEDEP(L,IW)-WDEPTH(IW))- WPRES(L,IW) )
               END DO
               BHP = X / DQWELLDWP(IW)
               WELBHP(IW) = BHP
C           IMPLICIT WELLS
            ELSE
               BHP =  OBHP + DWELBHP(IW)
               WELBHP(IW) = BHP
            ENDIF
            PLIM = PLIMIT(IW)
   
C           PRODUCER
            IF(IWTYPE(IW) > 0) THEN
               IF(BHP < PLIM) THEN
                  IF(OBHP > PLIM) THEN
                     IFLAG = 1
                     CHANGE_BHP = MIN((OBHP-PLIM)/(OBHP-BHP),
     &                                 CHANGE_BHP)
                  ENDIF
                  WELBHP(IW) = PLIM
               ENDIF
   
C           INJECTOR
            ELSE
               IF(BHP > PLIM) THEN
                  IF(OBHP < PLIM) THEN
                     IFLAG = 1
                     CHANGE_BHP = MIN((OBHP-PLIM)/(OBHP-BHP),
     &                                 CHANGE_BHP)
                  ENDIF
                  WELBHP(IW) = PLIM
               ENDIF
            ENDIF
         ENDIF
      END DO
      IF(IFLAG == 1) THEN
         CHANGE_BHP = MIN(ONE,(ONE+TEN_M2)*CHANGE_BHP)
      ENDIF
      END

C*********************************************************************
      SUBROUTINE XRATE
C*********************************************************************
 
C  UPDATES WELL RATES AT END OF TIMESTEP

C*********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xcompwel.h'
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IC,L,IPH
      REAL*8 X

      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT .OR. NWELPRC(IW) /= MYPRC) CYCLE
         IF(IWTYPE(IW) == 0) CYCLE
 
C        UPDATE RATE FOR CELL PRESSURE CHANGE IF BHP-CONTROLLED OR
C        UPDATE RATE FOR CELL AND WELL CHANGE IF IMPLICIT
         IF(BHP_CONTROL(IW) < 1 .OR. LINSYSW(IW) > 0) THEN
            DO IC = 1,NC
               WELL_COMP(IC,IW) = ZERO
            END DO
            DO L = 1,NUMELET(IW)
               X = WELBHP(IW) + WELDEN(IW)*(ELEDEP(L,IW)-WDEPTH(IW))
     &           - WPRES(L,IW)
               DO IC = 1,NC
                  WELL_COMP(IC,IW) = WELL_COMP(IC,IW) 
     &                             + WELL_COEF(IC,L,IW)*X
               END DO
            END DO
         ENDIF
 
C        DETERMINE PHASE RATES
         DO IPH = 1,NPH
            X = ZERO
            DO IC = 1,NC
               X= X + CONVERT_PH(IC,IPH,IW)*WELL_COMP(IC,IW)
            END DO
            WELL_PH(IPH,IW) = X
         END DO

      END DO
      END

C*********************************************************************
      SUBROUTINE XWELLCALC
C*********************************************************************
 
C  PERFORMS WELL CALCULATIONS FOR ALL WELLS

C*********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xcompwel.h'
      INCLUDE 'xiter.h'
      INCLUDE 'xbaldat.h'
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,JS,L,IC,IPH,I
      REAL*8 TE,PQ,DPQ
      REAL*8 COMP($MXCOMP+1)

C     SET TE SLIGHTLY LESS THAN TIM+DELTIM TO AVOID STEP FUNCTIONS
      TE = TIM+HALF*(ONE-TEN_M8)*DELTIM
      IF((NHISUSE == 0).AND.(NSTEP < 1)) TE = TIM
      DO IW = 1,NUMWEL
         WSHUT(IW) = .TRUE.
         IF(MODWEL(IW) /= MODACT .OR. NWELPRC(IW) /= MYPRC) CYCLE
         LINSYSW(IW) = 0
         IF(IWTYPE(IW) == 0) CYCLE
         CALL LOOKUP(NTABPQ(IW),TE,PQ,DPQ)

         IF(BHP_CONTROL(IW) >= 0) THEN
            RATE_IN(IW) = PQ
            IF(PQ == ZERO) CYCLE
         ELSE
            WELBHP(IW) = PQ
         ENDIF
         IF(IWTYPE(IW) > 0) THEN
            JS = IWSEP(IW)
            RATE_IN(IW) = -RATE_IN(IW)
            CALL XRATE_PROD1(ISEPTAB(1,JS),NUMELET(IW),NC,NPH,ICINPH,
     &           NHC,NFBUG,WSHUT(IW),INPUT_WGRAD(IW),WTEMPR(1,IW),
     &           WELL_COMP(1,IW),ELECONS(1,IW),WPRES(1,IW),WELDEN(IW),
     &           WELBHP(IW),WMOB(1,1,IW),WELL_COEF(1,1,IW),
     &           QLAYER(1,1,IW),BHP_CONTROL(IW),PLIMIT(IW),
     &           WELL_RESID(IW),WELL_RATE(IW),DQWELLDWP(IW),
     &           DQWELLDRP(1,IW),RATE_IN(IW),WELL_CONSTRAINT(1,IW),
     &           NSTAGE(JS),LCROSS(IW),WMOL,NCINPH,IFLINIT,
     &           WELL_KVAL(1,1,IW),TSEP(1,JS),PSEP(1,JS),
     &           CONVERT_PH(1,1,IW),CONVERT_IC(1,1,IW),IWTYPE(IW),
     &           WPMD(1,1,IW),WDEPTH(IW),ELEDEP(1,IW),ISEPTYP(JS),NEWT,
     &           IOPEN(1,IW),PHNAM)
         ELSE
            IF(IWTYPE(IW) == -1) THEN
               DO IC = 1,NC
                  COMP(IC) = ZERO
               END DO
               COMP(1) = ONE
            ELSE
               JS = INJCOMP(IW)
               DO IC = 1,NC
                  COMP(IC) = COMPINJ(IC,JS)
               END DO
            ENDIF
            CALL XRATE_INJ1(IFLINIT,NUMELET(IW),NC,NPH,ICINPH,NHC,NFBUG,
     &                   NFOUT,LEVELC,WSHUT(IW),INPUT_WGRAD(IW),COMP,
     &                   WTEMPR(1,IW),WELL_COMP(1,IW),ELECONS(1,IW),
     &                   WPRES(1,IW),WELDEN(IW),WELBHP(IW),WMOB(1,1,IW),
     &                   WELL_COEF(1,1,IW),QLAYER(1,1,IW),
     &                   BHP_CONTROL(IW),PLIMIT(IW),WELL_RESID(IW),
     &                   WELL_RATE(IW),DQWELLDWP(IW),DQWELLDRP(1,IW),
     &                   RATE_IN(IW),WELL_CONSTRAINT(1,IW),NCINPH,
     &                   WDEPTH(IW),ELEDEP(1,IW),DEN_IC(1,IW),NEWT,
     &                   IOPEN(1,IW))
         ENDIF
C
C        SET UP COEFFICIENTS FOR IMPLICIT WELL
C        NOTE: VCOFQ IN RESERVOIR EQUATION MUST BE SET LATER
         IF(IMPWEL(IW) > 0 .AND. BHP_CONTROL(IW) == 1) THEN
            LINSYSW(IW) = 1
            QRESID(IW) = WELL_RESID(IW)
            DWELBHP(IW) = ZERO
            QCOFN(1,IW) = DQWELLDWP(IW)
            DO L = 1,NUMELET(IW)
               QCOFW(1,L,IW) = DQWELLDRP(L,IW)
            END DO
         ENDIF
      END DO
      IF((NHISUSE == 0).AND.(NSTEP < 1)) RETURN

      IF(.NOT.BUGKEY(13)) RETURN
      IF(TIM < DUMPTIME1 .OR. TIM > DUMPTIME2) RETURN
      WRITE(NFBUG,'(A,F15.5,A,I5)') 
     &    ' WELL INFORMATION AT END OF XWELCALC  TIME = ',TIM,
     &    ' NEWT = ',NEWT
      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT .OR. NWELPRC(IW) /= MYPRC) CYCLE
         WRITE(NFBUG,'(3X,A,I5)') 'WELL ',IW
         WRITE(NFBUG,'(6X,A,F15.5)') 'WELDEN = ',WELDEN(IW)
         WRITE(NFBUG,'(6X,A,F15.5)') 'WELBHP = ',WELBHP(IW)
         WRITE(NFBUG,'(6X,A,I5)') 'BHP_CONTROL = ',BHP_CONTROL(IW)
         WRITE(NFBUG,'(6X,A,F15.5)') 'WELL_RATE = ',WELL_RATE(IW)
         WRITE(NFBUG,'(6X,A,E15.5)') 'WELL_RESID = ',WELL_RESID(IW)
         WRITE(NFBUG,'(6X,A,E15.5)') 'DQWELLDWP = ',DQWELLDWP(IW)
         IF(.NOT.BUGKEY(14)) CYCLE
         JS = IWSEP(IW)
         DO I = 1,NSTAGE(JS)
            WRITE(NFBUG,'(9X,A,I5)') 'ISTAGE =',I
            WRITE(NFBUG,'(12X,A,20E15.5)') 'WELL_KVAL = ',
     &                 (WELL_KVAL(IC,I,IW),IC=1,NHC)
         END DO
         WRITE(NFBUG,'(9X,A,10E15.5)') 'DQWELLDRP = ',(DQWELLDRP(L,IW),
     &                                  L=1,MIN(10,NUMELET(IW)))
         WRITE(NFBUG,'(6X,A)') '**** PHASE RATES ****'
         DO IPH = 1,NPH
            PQ = ZERO
            DO IC = 1,NC
               PQ = PQ + CONVERT_PH(IC,IPH,IW)*WELL_COMP(IC,IW)
            END DO
            WRITE(NFBUG,'(9X,A,I5,E15.5)') 'PHASE ',IPH,PQ
         END DO
         DO L = 1,MIN(NUMELET(IW),10)
            PQ = ZERO  
            DO IC = 1,NC
               PQ = PQ + QLAYER(IC,L,IW)
            END DO
            IF(PQ < ZERO) THEN
               WRITE(NFBUG,'(9X,A,I5,A)') 'LAYER = ',L,' PRODUCING'
            ELSEIF(PQ > ZERO) THEN
               WRITE(NFBUG,'(9X,A,I5,A)') 'LAYER = ',L,' INJECTING'
            ENDIF
         END DO
         IF(.NOT.BUGKEY(15)) CYCLE
         DO IPH = 1,NPH
            WRITE(NFBUG,'(6X,A,I5)') 'IPH =',IPH
            WRITE(NFBUG,'(12X,A,20E15.5)') 'CONVERT_PH = ',
     &                        (CONVERT_PH(IC,IPH,IW),IC=1,NC)
            WRITE(NFBUG,'(12X,A,20E15.5)') 'CONVERT_IC = ',
     &                        (CONVERT_IC(IC,IPH,IW),IC=1,NC)
         END DO
         DO L = 1,MIN(NUMELET(IW),10)
            WRITE(NFBUG,'(9X,A,I5)') 'LAYER =',L
            WRITE(NFBUG,'(12X,A,I5,5E15.5)') 'L,WMOB = ',L,
     &                   (WMOB(IC,L,IW),IC=1,NPH)
         END DO
         DO L = 1,MIN(NUMELET(IW),10)
            WRITE(NFBUG,'(9X,A,I5)') 'LAYER =',L
            WRITE(NFBUG,'(12X,A,I5,2E15.5)') 'L,WPRES,ELEDEP = ',L,
     &                   WPRES(L,IW),ELEDEP(L,IW)
         END DO
         DO IC = 1,NCPRT
            WRITE(NFBUG,'(6X,A,I5)') 'IC =',IC
            WRITE(NFBUG,'(9X,A,E15.5)') 'WELL_COMP = ',WELL_COMP(IC,IW)
            DO L = 1,MIN(NUMELET(IW),10)
               WRITE(NFBUG,'(9X,A,I5)') 'LAYER =',L
               WRITE(NFBUG,'(12X,A,E15.5)') 'QLAYER = ',QLAYER(IC,L,IW)
               WRITE(NFBUG,'(12X,A,E15.5)') 'WELL_COEF = ',
     &                                       WELL_COEF(IC,L,IW)
            END DO
         END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XWELVAL1(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                    KL2,KEYOUT,NBLK,TEMPR,MOB,PMD)
C*********************************************************************
 
C  ROUTINE GATHERS WELL VALUES REQUIRED FOR WELLBORE CALCULATIONS.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 MOB(IDIM,JDIM,KDIM,NPH),PMD(IDIM,JDIM,KDIM,NCINPH),
     &       TEMPR(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,IPH,L,I,J,K

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT) CYCLE
         NE = NUMELE(IW)
         DO  L = 1,NE
            IF (LOCWEL(6,L,IW)==MYPRC .AND. LOCWEL(1,L,IW)==NBLK) THEN
               I = LOCWEL(3,L,IW)-IOFF
               J = LOCWEL(4,L,IW)-JOFF
               K = LOCWEL(5,L,IW)-KOFF
               IF(KEYOUT(I,J,K) /= 1) CYCLE
               WTEMPR(L,IW) = TEMPR(I,J,K)
               DO IPH = 1,NPH
                  WMOB(IPH,L,IW) = MOB(I,J,K,IPH)
               END DO
               DO IPH = 1,NCINPH
                  WPMD(IPH,L,IW) = PMD(I,J,K,IPH)
               END DO
            ENDIF
         END DO   
      END DO
      END

C*********************************************************************
      SUBROUTINE XGET_WPRES
C*********************************************************************
C GATHERS WPRES FOR WELL ELEMENTS FOR WELLS THAT SPAN SEVERAL PROCESSORS
C
C-----------------------------------------------------------------------
      INCLUDE 'control.h'
      INCLUDE 'xwells.h'
      INCLUDE 'wells.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IW,K

$MANY      DO IW = 1,NUMWEL
$MANY         IF(NWELPRC(IW) == MYPRC) THEN
$MANY            CALL ELEGET(IW,1,WPRES(NUMELE(IW)+1,IW))
$MANY         ELSE
$MANY            CALL ELEGET(IW,1,WPRES(1,IW))
$MANY         ENDIF
$MANY      END DO
      RETURN
      END

C*********************************************************************
      SUBROUTINE XGET_ELEVAL
C*********************************************************************
C GATHERS WELL ELEMENTS FOR WELLS THAT SPAN SEVERAL PROCESSSORS
C
C-----------------------------------------------------------------------
      INCLUDE 'control.h'
      INCLUDE 'xwells.h'
      INCLUDE 'wells.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IW,K,L,I,N
      REAL*8 WSUM((NPH+NCINPH+1)*$MXWELE)

$MANY      N = NPH + NCINPH + 1
$MANY      DO IW = 1,NUMWEL
$MANY         IF(NWELPRC(IW) /= MYPRC) THEN
$MANY            K = 0
$MANY            DO L = 1,NUMELE(IW)
$MANY               K = K + 1
$MANY               WSUM(K) = WTEMPR(L,IW)
$MANY               DO I = 1,NPH
$MANY                  K = K + 1
$MANY                  WSUM(K) = WMOB(I,L,IW)
$MANY               END DO
$MANY               DO I = 1,NCINPH
$MANY                  K = K + 1
$MANY                  WSUM(K) = WPMD(I,L,IW)
$MANY               END DO
$MANY            END DO
$MANY         ENDIF
$MANY         CALL ELEGET(IW,N,WSUM)
$MANY         IF(NWELPRC(IW) == MYPRC) THEN
$MANY            K = 0
$MANY            DO L = NUMELE(IW)+1,NUMELET(IW)
$MANY               K = K + 1
$MANY               WTEMPR(L,IW) = WSUM(K)
$MANY               DO I = 1,NPH
$MANY                  K = K + 1
$MANY                  WMOB(I,L,IW) = WSUM(K)
$MANY               END DO
$MANY               DO I = 1,NCINPH
$MANY                  K = K + 1
$MANY                  WPMD(I,L,IW) = WSUM(K)
$MANY               END DO
$MANY            END DO
$MANY         ENDIF
$MANY      END DO
      RETURN
      END

C*********************************************************************
      SUBROUTINE XPUT_ELEVAL
C*********************************************************************
C DISTRIBUTES WELL ELEMENTS FOR WELLS THAT SPAN SEVERAL PROCESSSORS
C
C-----------------------------------------------------------------------
      INCLUDE 'control.h'
      INCLUDE 'xwells.h'
      INCLUDE 'wells.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IW,K,L,I,N
      REAL*8 WSUM(2*NC*$MXWELE)

$MANY      N = 2*NC
$MANY      DO IW = 1,NUMWEL
$MANY         IF(NWELPRC(IW) == MYPRC) THEN
$MANY            K = 0
$MANY            DO L = NUMELE(IW)+1,NUMELET(IW)
$MANY               DO I = 1,NC
$MANY                  K = K + 1
$MANY                  WSUM(K) = QLAYER(I,L,IW)
$MANY               END DO
$MANY               DO I = 1,NC
$MANY                  K = K + 1
$MANY                  WSUM(K) = WELL_COEF(I,L,IW)
$MANY               END DO
$MANY            END DO
$MANY         ENDIF
$MANY         CALL ELEPUT(IW,N,WSUM)
$MANY         IF(NWELPRC(IW) /= MYPRC) THEN
$MANY            K = 0
$MANY            DO L = 1,NUMELE(IW)
$MANY               DO I = 1,NC
$MANY                  K = K + 1
$MANY                  QLAYER(I,L,IW) = WSUM(K)
$MANY               END DO
$MANY               DO I = 1,NC
$MANY                  K = K + 1
$MANY                  WELL_COEF(I,L,IW) = WSUM(K)
$MANY               END DO
$MANY            END DO
$MANY         ENDIF
$MANY      END DO
      RETURN
      END

C*********************************************************************
      SUBROUTINE XPUT_WELVAL
C*********************************************************************
C DISTRIBUTES WELL VALUES FOR WELLS THAT SPAN SEVERAL PROCESSSORS
C
C-----------------------------------------------------------------------
      INCLUDE 'control.h'
      INCLUDE 'xwells.h'
      INCLUDE 'wells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      PARAMETER(NVAL = 4)
      INTEGER IW,K
      REAL*8 WSUM(NVAL)

$MANY      DO IW = 1,NUMWEL
$MANY         IF(NWELPRC(IW) == MYPRC) THEN
$MANY            K = 1
$MANY            WSUM(K) = BHP_CONTROL(IW)
$MANY            K = K + 1
$MANY            IF(WSHUT(IW)) THEN
$MANY               WSUM(K) = ONE
$MANY            ELSE
$MANY               WSUM(K) = ZERO
$MANY            ENDIF
$MANY            K = K + 1
$MANY            WSUM(K) = WELBHP(IW)
$MANY            K = K + 1
$MANY            WSUM(K) = WELDEN(IW)
$MANY         ENDIF
$MANY         CALL WELDIST(IW,NVAL,WSUM)
$MANY         IF(NWELPRC(IW) /= MYPRC .AND. NUMELE(IW) > 0) THEN
$MANY            K = 1
$MANY            IF(WSUM(K) >= ZERO) THEN
$MANY               BHP_CONTROL(IW) = WSUM(K)+.01
$MANY            ELSE
$MANY               BHP_CONTROL(IW) = WSUM(K)-.01
$MANY            ENDIF
$MANY            K = K + 1
$MANY            IF(WSUM(K) == ONE) THEN
$MANY               WSHUT(IW) = .TRUE.
$MANY            ELSE
$MANY               WSHUT(IW) = .FALSE.
$MANY            ENDIF
$MANY            K = K + 1
$MANY            WELBHP(IW) = WSUM(K)
$MANY            K = K + 1
$MANY            WELDEN(IW) = WSUM(K)
$MANY         ENDIF
$MANY      END DO
      RETURN
      END

C*********************************************************************
      SUBROUTINE XSET_WPRES(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                      KL2,KEYOUT,NBLK,PRES,MDENN,DEPTH,SAT)
C*********************************************************************
 
C  ROUTINE SETS CELL PRESSURE REQUIRED FOR WELLBORE CALCULATIONS.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 PRES(IDIM,JDIM,KDIM),MDENN(IDIM,JDIM,KDIM,NPH),
     &       DEPTH(IDIM,JDIM,KDIM),SAT(IDIM,JDIM,KDIM,NPH)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,IPH,L,I,J,K
      REAL*8 GRAD

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT) CYCLE
         NE = NUMELE(IW)
         DO  L = 1,NE
            IF (LOCWEL(6,L,IW)==MYPRC .AND. LOCWEL(1,L,IW)==NBLK) THEN
               I = LOCWEL(3,L,IW)-IOFF
               J = LOCWEL(4,L,IW)-JOFF
               K = LOCWEL(5,L,IW)-KOFF
               IF(KEYOUT(I,J,K) /= 1) CYCLE
C              MDENN MAY BE ZERO FOR NONEXISTENT PHASE
               GRAD = ZERO
               DO IPH = 1,NPH
                  GRAD = GRAD + SAT(I,J,K,IPH)*MDENN(I,J,K,IPH)
               END DO
               WPRES(L,IW) = PRES(I,J,K) + GRAV*GRAD* 
     &                      (ELEDEP(L,IW)-DEPTH(I,J,K))
            ENDIF
         END DO   
      END DO
      END

C*********************************************************************
      SUBROUTINE XWELFLOW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                    KL2,KEYOUT,NBLK,DFLOW,RESID)
C*********************************************************************
 
C  ADDS WELL TERMS TO FLOW EQUATIONS.
C  THIS IS A WORK ROUTINE.

C  INPUT/OUTPUT:
C     RESID(I,J,K,IC) = RESIDUAL FOR RIGHT HAND SIDE (REAL*8)
C     DFLOW(I,J,K,IC) = DIAGONAL FLOW COEFFICIENT FOR P(I,J,K) 
C                       IN (I,J,K,IC) MASS CONSERVATION EQUATION (REAL*8)

C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 RESID(IDIM,JDIM,KDIM,NC),DFLOW(IDIM,JDIM,KDIM,NC)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,IC,L,I,J,K

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT) CYCLE
         IF(WSHUT(IW)) CYCLE
         NE = NUMELE(IW)
         DO  L = 1,NE
            IF (LOCWEL(6,L,IW)==MYPRC .AND. LOCWEL(1,L,IW)==NBLK) THEN
               I = LOCWEL(3,L,IW)-IOFF
               J = LOCWEL(4,L,IW)-JOFF
               K = LOCWEL(5,L,IW)-KOFF
               IF(KEYOUT(I,J,K) /= 1) CYCLE
               DO IC = 1,NC
                  RESID(I,J,K,IC) = RESID(I,J,K,IC) 
     &                            - DELTIM*QLAYER(IC,L,IW)
               END DO

C              WELL ON BOTTOMHOLE PRESSURE CONTROL OR IMPLICIT WELL
               IF(BHP_CONTROL(IW) < 1 .OR. LINSYSW(IW) > 0) THEN 
                  DO IC = 1,NC
                     DFLOW(I,J,K,IC) = DFLOW(I,J,K,IC)
     &                               + DELTIM*WELL_COEF(IC,L,IW)
                  END DO
               ENDIF
            ENDIF
         END DO   
      END DO
      END

C*********************************************************************
      SUBROUTINE XWFLOW(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                 KL2,KEYOUT,NBLK,DELC)
C*********************************************************************
 
C  ADD WELL CONTRIBUTION TO CONCENTRATION UPDATE.
C  THIS IS A WORK ROUTINE.

C  INPUT/OUTPUT:
C     CONC(I,J,K,IC) = CONCENTRATION FOR CELL (REAL*8)

C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 DELC(IDIM,JDIM,KDIM,NC)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,IC,L,I,J,K
      REAL*8 DELPW

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT) CYCLE
         IF(LINSYSW(IW) < 1) CYCLE
         NE = NUMELE(IW)
         DELPW = DWELBHP(IW)
         DO  L = 1,NE
            IF (LOCWEL(6,L,IW)==MYPRC .AND. LOCWEL(1,L,IW)==NBLK) THEN
               I = LOCWEL(3,L,IW)-IOFF
               J = LOCWEL(4,L,IW)-JOFF
               K = LOCWEL(5,L,IW)-KOFF
               IF(KEYOUT(I,J,K) /= 1) CYCLE
               DO IC = 1,NC
                  DELC(I,J,K,IC) = DELC(I,J,K,IC) 
     &                            + DELTIM*WELL_COEF(IC,L,IW)*DELPW
               END DO
            ENDIF
         END DO   
      END DO
      END

C*********************************************************************
      SUBROUTINE XWELCOND(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                    KL2,KEYOUT,NBLK,SCAL)
C*********************************************************************
 
C  SETS UP WELL COEFFICIENT FOR IMPLICIT WELLS.
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     SCAL(I,J,K,IC) = SCALING FACTOR FOR IMPEC (REAL*8)

C  OUTPUT:
C     VCOFQ(1,L,IC) = IMPEC COEEFICIENT FOR WELL PRESSURE (REAL*4)

C*********************************************************************
$POWER      INCLUDE 'msjunk.h'
      INCLUDE 'control.h'
      INCLUDE 'wells.h'
      INCLUDE 'layout.h'
      INCLUDE 'xwells.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 SCAL(IDIM,JDIM,KDIM,NC)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IW,IOFF,JOFF,KOFF,MERR,NE,IC,L,I,J,K
      REAL*8 VAL

C     GET LOCAL TO GLOBAL INDEX OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,MERR)

      DO IW = 1,NUMWEL
         IF(MODWEL(IW) /= MODACT) CYCLE
         IF(LINSYSW(IW) < 1) CYCLE
         NE = NUMELE(IW)
         DO  L = 1,NE
            IF (LOCWEL(6,L,IW)==MYPRC .AND. LOCWEL(1,L,IW)==NBLK) THEN
               I = LOCWEL(3,L,IW)-IOFF
               J = LOCWEL(4,L,IW)-JOFF
               K = LOCWEL(5,L,IW)-KOFF
               IF(KEYOUT(I,J,K) /= 1) CYCLE
               VAL = ZERO
               DO IC = 1,NC
                  VAL = VAL + SCAL(I,J,K,IC)*WELL_COEF(IC,L,IW)
               END DO
               VCOFQ(1,L,IW) = DELTIM*VAL 
            ENDIF
         END DO   
      END DO
      END

C*********************************************************************
      SUBROUTINE XRATE_INJ1(IFLINIT,NCOMP,NC,NPH,ICINPH,NHC,NFBUG,
     &                      NFOUT,LEVELC,SHUT,INPUT_WGRAD,CONC,TEMPR,
     &                      WELL_COMP,ELECONS,PCOMP,GRAD,PW,MOB,
     &                      WELL_COEF,QLAYER,BHP_CONTROL,PLIMIT,
     &                      WELL_RESID,WELL_RATE,DQWELLDWP,DQWELLDRP,
     &                      RATE_IN,WELL_CONSTRAINT,NCINPH,WDEPTH,
     &                      HCOMP,DEN_IC,NEWT,IOPEN)
C*********************************************************************
C PERFORMS WELL CALCULATES FOR INJECTION WELLS
C CALCULATES BOTTOMHOLE PRESSURES FOR WELLS ON RATE CONTROL.  
C CALCULATES RATES FOR WELLS THAT ARE BOTTOMHOLE PRESSURE LIMITED.
C PERFORMS ITERATIONS ON BOTTOMHOLE PRESSURE TO ARRIVE AT CONVERGED PRESSURE.
C
C WELL CAN BE LIMITED BY: (1) COMBINATION OF SURFACE COMPONENT RATES
C                         (2) BOTTOMHOLE PRESSURE
C
C OUTPUT IS: (1) COMPONENT RATES AT EACH COMPLETION (QLAYER).
C            (2) NEW WELLBORE GRADIENT IF NOT CONSTANT (GRAD).
C            (3) TOTAL COMPONENT RATE FOR WELL (WELL_COMP).
C            (4) WELL COEFFICIENTS (WELL_COEF).
C            (5) BOTTOMHOLE PRESSURE (PW).
C            (6) INACTIVE INDICATOR (SHUT).
C            (7) BHP CONTROL INDICATOR (BHP_CONTROL).
C            (8) CONSTRAINT COEFFICIENTS AND RESIDUAL (WELL_RESID,DQWELLDRP,
C                DQWELLDWP).
C            (9) CONSTRAINT RATE (RATE).
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xiter.h'
CDBG      INCLUDE 'xthermal.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IFLINIT,NCOMP,NC,NPH,ICINPH($MXCOMP+1,$MXPHASE),
     &        NHC,NFBUG,NFOUT,BHP_CONTROL,NCINPH,NEWT,IOPEN(NCOMP)
      LOGICAL SHUT,LEVELC,INPUT_WGRAD
      REAL*4 ELECONS(NCOMP),HCOMP(NCOMP)
      REAL*8 CONC(NC),TEMPR(NCOMP),PCOMP(NCOMP),
     &       GRAD,PW,WELL_RESID,WELL_RATE,WELL_COMP(NC),
     &       WELL_COEF($MXCOMP+1,NCOMP),QLAYER($MXCOMP+1,NCOMP),
     &       DQWELLDWP,DQWELLDRP(NCOMP),MOB($MXPHASE,NCOMP),
     &       PLIMIT,RATE_IN,WELL_CONSTRAINT(NC),WDEPTH,
     &       DEN_IC(NC)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER TEMPR_SELECT
CDBG     &       ,IWERR
      INTEGER L,IC,IFLPNT,K,ITER,NITER,IPH,ICON,ITAB,I
      PARAMETER (NITER = 50)
      LOGICAL LBRENT,CONVERGE
      REAL*8 X,DELP(NCOMP),TOTAL_MOB(NCOMP),F1,F2,FVAL,WKH(NCOMP),
     &       P1,P2,DIFF_PW,DIFF_RATE,RATE,PCOEF,RATE_ERROR,XPW,
     &       HIGH,LOW,Y,WCOEF($MXCOMP+1,NCOMP),TWELL,DELH(NCOMP)
CDBG      DATA IWERR/0/
      PARAMETER (HIGH = .75D0)
      PARAMETER (LOW = .25D0)
 
C-----------------------------------------------------------------------
C  INPUT:
C     ITAB       = TABLE NUMBER FOR FLASH.
C     NCOMP      = NUMBER OF WELL COMPLETIONS.
C     NC         = NUMBER OF COMPONENTS.
C     NPH        = NUMBER OF FLUID PHASES.
C     ICINPH     = POSITION NUMBER IN PMD FOR EACH COMPONENT IN EACH PHASE.
C     NHC        = NUMBER OF HYDROCARBON COMPONENTS.
C     NFBUG      = UNIT NUMBER FOR PRINTOUT.
C     NFOUT      = UNIT NUMBER FOR STANDARD OUTPUT.
C     LEVELC     = LOGICAL TO CONTROL PRINTS TO STANDARD OUTPUT.
C     INPUT_WGRAD= .TRUE. IF WELL GRADIENT SUPPLIED AS INPUT DATA.
C     CONC(IC)   = INJECTION COMPOSITION FOR WELL.
C     TEMPR(N)   = TEMPERATURE AT COMPLETION N.
C     ELECONS(N) = WELLBORE CONSTANT FOR WELL COMPLETION N.
C     PRES(N)    = PRESSURE IN COMPLETION N.            
C     DELH(N)    = RELATIVE DEPTH OF COMPLETION N.
C     MOB(IPH,N) = MOBILITY OF PHASE IPH FOR COMPLETION N.
C     PW         = BOTTOMHOLE PRESSURE FOR WELL.
C     IFLINIT    = FLUID POINTER FOR INITIAL FLASH STATE.
C     TOL_PW     = CONVERGENCE TOLERANCE FOR WELL PRESSURES.
C     TOL_RATE   = RELATIVE CONVERGENCE TOLERANCE FOR RATE CONSTRAINT EQN.
C     PLIMIT     = LIMITING PRESSURE FOR RATE CONSTRAINTED WELLS.
C     RATE_IN    = RATE CONSTRAINT FOR WELL.
C     WELL_CONSTRAINT(IC)=CONSTRAINT MULTIPLIER FOR COMPONENT IC.

C  INPUT/OUTPUT:
C     GRAD       = WELLBORE GRADIENT FOR WELL.
C     BHP_CONTROL= 1 IF WELL ON RATE CONTROL.
C                  0 IF WELL BHP LIMITED.
C                 -1 IF WELL ON BHP CONTROL

C  OUTPUT:
C     SHUT       = .TRUE. IF WELL IS CANNOT FLOW.
C     WELL_COMP(IC)=COMPONENT RATES FOR WELL.
C     WELL_COEF(IC,N)=WELL EQN COEFFICIENT FOR COMPONENT IC, COMPLETION N.
C                     INCLUDES WKH TERM WHEN EXITING ROUTINE.
C     QLAYER(IC,N)= COMPONENT RATES FOR COMPLETION N.
C     WELL_RESID = RESIDUAL FOR WELL CONSTRAINT EQN.
C     WELL_RATE =  WELL RATE FOR CONSTRAINT EQUATION
C     DQWELLDWP =  PW COEFFICIENT IN WELL CONSTRAINT EQN.
C     DQWELLDRP(N)=PRESSURE COEFFICIENTS IN WELL CONSTRAINT EQN.
C
C-----------------------------------------------------------------------

C     INITIALIZE WELL TERMS
      IF(NEWT == 1) THEN
         DO L = 1,NCOMP
            IF(ELECONS(L) > ZERO) THEN
               IOPEN(L) = 1
            ELSE
               IOPEN(L) = 0
            ENDIF
         END DO
      ENDIF
      WELL_RESID = ZERO
      WELL_RATE = ZERO
      DO IC = 1,NC
         WELL_COMP(IC) = ZERO
      END DO
      DO L = 1,NCOMP
         DO IC = 1,NC
            QLAYER(IC,L) = ZERO
            WELL_COEF(IC,L) = ZERO
         END DO
      END DO
      DO L = 1,NCOMP
         DELH(L) = HCOMP(L)-WDEPTH
         DQWELLDRP(L) = ZERO
         IF(IOPEN(L) > 0) THEN
            WKH(L) = CWKH * ELECONS(L)
         ELSE
            WKH(L) = ZERO
         ENDIF
      END DO
      DQWELLDWP = ZERO
      IF(BHP_CONTROL == 1) BHP_CONTROL = 0
      IFLPNT = IFLINIT
 
C     SET UP TOTAL WELL MOBILITY AND TEMPERATURE
C     CHECK THAT AT LEAST ONE LAYER IS AVAILABLE FOR FLOW
      K = 0
      TWELL = ZERO
      DO L = 1,NCOMP
         IF(IOPEN(L) > 0) THEN
            X = ZERO
            DO IPH = 1,NPH
               X = X + MOB(IPH,L)
            END DO
            TOTAL_MOB(L) = X
            IF(X > ZERO) THEN
               K = K + 1
               TWELL = TWELL + TEMPR(L)
            ENDIF
         ELSE
            TOTAL_MOB(L) = ZERO
         ENDIF
      END DO
      IF(K == 0) RETURN
      TWELL = TWELL / K
      ITAB = TEMPR_SELECT(TWELL)
CDBG      CALL SET_EOS_PARM(ITAB,TWELL,NFOUT,LEVELC,IWERR,DEL_TR)

C     SET INITIAL PW SO AT LEAST ONE LAYER INJECTS
C     FOR RATE CONTROLLED WELLS SET LIMITS ON PW. REQUIRES P1 <= PW <= P2
      IF(BHP_CONTROL == 0) THEN
         P2 = PLIMIT
         P1 = BIG
         K = 0
         DO L = 1,NCOMP
            IF(TOTAL_MOB(L) <= ZERO) CYCLE
            IF(PW - PCOMP(L) + GRAD*DELH(L) > ZERO) K = 1
C           ASSUME GRAD = 1
            IF(DELH(L) >= ZERO) THEN
               P1 = MIN(P1,PCOMP(L)-DELH(L))
C           ASSUME GRAD = 0
            ELSE
               P1 = MIN(P1,PCOMP(L))
            ENDIF
         END DO
         IF(P1 > P2) RETURN
         PW = MAX(P1,MIN(P2,PW))
       
C        FIND PW THAT INJECTS INTO AT LEAST ONE LAYER
         IF(K == 0) THEN
            PW = MIN(P1 + TEN_P2, P2)
            DO I = 1,11 
               K = 0
               DO L = 1,NCOMP
                  IF(TOTAL_MOB(L) <= ZERO) CYCLE
                  IF(PW - PCOMP(L) + GRAD*DELH(L) > ZERO) K = 1
               END DO
               IF(K /= 0) EXIT
               PW = MIN(PW + TEN_P2, P2)
               IF(I == 10) PW = P2
            END DO
            IF( K == 0) RETURN
         ENDIF
C         WRITE(NFBUG,'(A,F15.5,F15.8)') ' PW,GRAD ',PW,GRAD
C         WRITE(NFBUG,'(A,F15.5,F15.8)') ' P1,P2 ',P1,P2

C     BHP PRESCRIBED
      ELSE
         K = 0
         DO L = 1,NCOMP
            IF(TOTAL_MOB(L) <= ZERO) CYCLE
            IF(PW - PCOMP(L) + GRAD*DELH(L) > ZERO) K = 1
         END DO
         IF(K == 0) RETURN
      ENDIF

C-----------------------------------------------------------------------
C           BEGIN ITERATIONS
C-----------------------------------------------------------------------

C     DEFINE FVAL = RATE_IN - RATE FOR PREVIOUS ITERATION
C     FIRST SEVERAL NONZERO RATE ESTIMATES USE CONSTRAINT EQUATION TO GET PW
C     SECOND NONZERO RATE ESTIMATE USES BISECTION TO GET PW
C     QUADRATIC INTERPOLATION USED TO GET PW ONCE SOLUTION IS BOUNDED
      ICON = 0
      LBRENT = .FALSE.
      DO ITER = 1,NITER
C         WRITE(NFBUG,'(A,I5)') ' ITERATION ',ITER

C        DETERMINE WELL COEFFICIENTS, CROSSFLOW, GRAD, SHUT VALUES
         CALL XRATE_INJ2(IFLPNT,ITAB,NCOMP,NC,NPH,ICINPH,NHC,
     &                   NFBUG,SHUT,INPUT_WGRAD,CONC,TWELL,
     &                   WKH,PCOMP,DELH,GRAD,PW,TOTAL_MOB,
     &                   WCOEF,ITER,NCINPH,DEN_IC,NEWT)
C         WRITE(NFBUG,'(A,F15.8)') '    GRAD ',GRAD
      
C        SETUP PRESSURE DROP (DELP > 0 FOR INJECTING LAYER)
C        INCLUDES WELLBORE CONSTANT
         IF(SHUT) THEN
            RATE_ERROR = RATE_IN
            RATE = ZERO
         ELSE
            DO L = 1,NCOMP
               DELP(L) = WKH(L)*((PW-PCOMP(L))+GRAD*DELH(L))
C               WRITE(NFBUG,'(A,I5,F15.5)') '    DELP ',L,DELP(L)
            END DO
            RATE = ZERO
            PCOEF = ZERO
            DO L = 1,NCOMP
               IF(DELP(L) <= ZERO) CYCLE
               X = ZERO
               DO IC = 1,NC
                  X = X + WCOEF(IC,L)*WELL_CONSTRAINT(IC)
               END DO
               PCOEF = PCOEF + WKH(L)*X
               RATE = RATE + X*DELP(L)
            END DO
            RATE_ERROR = RATE_IN - RATE
         ENDIF
C         WRITE(NFBUG,'(A,F15.5,F15.8)') '    RATE,RATE_ERROR ',RATE,
C     &                                       RATE_ERROR

C-----------------------------------------------------------------------
C        PRESSURE SPECIFIED WELL
C-----------------------------------------------------------------------
         IF(BHP_CONTROL == -1) THEN
            IF(RATE >= ZERO) THEN
               CONVERGE = .TRUE.
               EXIT
            ELSE
               RETURN
            ENDIF

C-----------------------------------------------------------------------
C        PRESSURE LIMITED WELL
C-----------------------------------------------------------------------
         ELSEIF(PW == PLIMIT) THEN
C            WRITE(NFBUG,'(A)') '    BHP LIMITED '
            IF(SHUT) RETURN
            XPW = PW + RATE_ERROR/PCOEF
            XPW = MIN(PLIMIT,MAX(XPW,HALF*(P1+P2)))
            DIFF_PW= ABS(PW - XPW)

C-----------------------------------------------------------------------
C        RATE LIMITED WELL
C-----------------------------------------------------------------------
         ELSE

C           ESTIMATE RATE ERROR
C           PW TOO LOW IF RATE_ERROR > 0
            DIFF_RATE = ABS(RATE_ERROR)
            IF( DIFF_RATE <= ABS(TOL_RATE*RATE_IN)) THEN
               CONVERGE = .TRUE.
               EXIT
            ENDIF

C           NO INJECTION OF CONSTRAINT FLUID
            IF(RATE == ZERO) THEN 
C               WRITE(NFBUG,'(A)') '    RATE == ZERO'
               IF(PW == PLIMIT) RETURN
               P1 = PW
               X = TEN*ITER
               XPW = MIN(P2,PW+X)
               DIFF_PW = BIG
 
C           ESTIMATE PW USING QUADRATIC INTERPOLATION
C           ONLY DOES BRENT IF SOLUTION HAS BEEN BOUNDED
            ELSEIF(LBRENT) THEN 
C               WRITE(NFBUG,'(A)') '    BRENT '
               XPW = PW
C              GET NEW ESTIMATE XPW AND RESET P1 OR P2 TO MAINTAIN BOUND
               CALL BRENT_ROOT(XPW,RATE_ERROR,P1,F1,P2,F2,DIFF_PW)
               DIFF_PW = ABS(DIFF_PW)
               IF(XPW > PW) THEN
                  P1 = PW
               ELSE
                  P2 = PW
               ENDIF
 
C           ESTIMATE PW USING BISECTION OR SET BOUNDS
C           ICON IS NUMBER OF CONSTRAINT ESTIMATES
            ELSEIF(ICON > 3) THEN
               IF(RATE_ERROR >= ZERO) THEN
                  P1 = PW
               ELSE
                  P2 = PW
               ENDIF
 
C              ROOT IS BOUNDED BETWEEN AND PW
               IF(RATE_ERROR*FVAL < ZERO) THEN
C                  WRITE(NFBUG,'(A)') '    SET BOUNDS'
                  IF(PW == P2) THEN 
                     F1 = FVAL
                     F2 = RATE_ERROR
                  ELSE
                     F2 = FVAL
                     F1 = RATE_ERROR
                  ENDIF
                  IF(ABS(F1) > ABS(F2)) THEN
                     XPW = LOW*P1 + HIGH*P2
                  ELSE
                     XPW = HIGH*P1 + LOW*P2
                  ENDIF
                  LBRENT = .TRUE.
 
C              SOLUTION NOT BOUNDED YET
               ELSE
C                  WRITE(NFBUG,'(A)') '    BISECTION'
                  XPW = HALF*(P1+P2)
               ENDIF  
   
C           PREDICT PW USING CONSTRAINT EQUATION
C           ALWAYS COMES HERE FOR FIRST ITERATION WHERE RATE /= ZERO
C           UNLESS PRESSURE LIMITED
            ELSE
C              WRITE(NFBUG,'(A)') '    USE CONSTRAINT EQUATION'
               ICON = ICON + 1
               IF(RATE_ERROR >= ZERO) THEN
                  P1 = PW
               ELSE
                  P2 = PW
               ENDIF
               XPW = PW + RATE_ERROR/PCOEF
               IF(XPW < P1) THEN
                  XPW = P1
                  ICON = 100
               ELSEIF(XPW > P2) THEN
                  XPW = P2
                  ICON = 100
               ENDIF
            ENDIF
            DIFF_PW = ABS(XPW-PW)
         ENDIF
 
         PW = XPW
C         WRITE(NFBUG,'(A,F15.5)') '    NEW PW ESTIMATE ',PW
         FVAL = RATE_ERROR
         IF(DIFF_PW <= TOL_PW) THEN
            CONVERGE = .TRUE.
            EXIT
         ENDIF
      END DO 
C-----------------------------------------------------------------------
C     FINISH PROCESSING WELL
C-----------------------------------------------------------------------
      IF(BHP_CONTROL /= -1) THEN
         IF(ABS(PW-PLIMIT) < TOL_PW) THEN
            PW = PLIMIT
C            WRITE(NFBUG,'(A)') '    WELL IS ON BHP CONTROL'
         ELSE
C            WRITE(NFBUG,'(A)') '    WELL IS ON RATE CONTROL'
            BHP_CONTROL = 1
         ENDIF
      ENDIF
      DO L = 1,NCOMP
         DO IC = 1,NC
            WELL_COEF(IC,L) = WKH(L) * WCOEF(IC,L)
         END DO
      END DO
      DO IC = 1,NC
         WELL_COMP(IC) = ZERO
      END DO
      WELL_RATE = ZERO
      PCOEF = ZERO
      DO L = 1,NCOMP
         X = ZERO
         Y = PW+GRAD*DELH(L)-PCOMP(L)
         IF(Y < ZERO) IOPEN(L) = 0
         DO IC = 1,NC
            X = X + WELL_CONSTRAINT(IC) * WELL_COEF(IC,L)
            QLAYER(IC,L) = WELL_COEF(IC,L)*Y
            WELL_COMP(IC) = WELL_COMP(IC) + QLAYER(IC,L)
         END DO
         DQWELLDRP(L) = -X
         PCOEF = PCOEF + X 
         WELL_RATE = WELL_RATE + X*Y
      END DO
      DQWELLDWP = PCOEF
      WELL_RESID = RATE_IN - WELL_RATE
      END 

C*********************************************************************
      SUBROUTINE XRATE_INJ2(IFLDPNT,ITAB,NCOMP,NC,NPH,ICINPH,NHC,
     &                      NFBUG,SHUT,INPUT_WGRAD,CONC,TWELL,
     &                      WKH,PCOMP,DELH,GRAD,PW,TOTAL_MOB,
     &                      WELL_COEF,ITER,NCINPH,DEN_IC,NEWT)
C*********************************************************************
C CALCULATES COMPONENT RATES FOR AN INJECTION WELL. 
C REQUIRES PW AND ESTIMATE OF WELL GRADIENT.
C INJECTION COMPOSITION REQUIRED. INJECTORS CANNOT CROSSFLOW. 
C
C OUTPUT IS: 
C            (1) NEW WELLBORE GRADIENT IF NOT CONSTANT (GRAD).
C            (2) COMPONENT COEFFICIENT FOR WELL TERMS (WELL_COEF).
C            (3) SHUT-IN FLAG (SHUT).
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IFLDPNT,ITAB,NCOMP,NC,NPH,ICINPH($MXCOMP+1,$MXPHASE),
     &        NHC,NFBUG,ITER,NCINPH,NEWT
      LOGICAL SHUT,INPUT_WGRAD
      REAL*8 CONC(NC),TWELL,PCOMP(NCOMP),DELH(NCOMP),GRAD,WKH(NCOMP),
     &       PW,TOTAL_MOB(NCOMP),WELL_COEF($MXCOMP+1,NCOMP),DEN_IC(NC)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER L,IC,NINJ,IPH,K
      LOGICAL OPEN(NCOMP)
      REAL*8 X,DUM(NC),DELP(NCOMP),GRAV,DUMC(NC)
      PARAMETER (GRAV = .006944445D0)
 
C     FOLLOWING VARIABLES SAVED TO SPEED UP FLASH FOR REPEATED CALLS
      REAL*8  FLZ(3),FLV(2),PMD($MXICPH),FLK($MXCOMP),
     &        SAT($MXPHASE),MDEN($MXPHASE)
      SAVE FLZ,FLV,PMD,FLK,SAT,MDEN
C-----------------------------------------------------------------------
C  INPUT:
C     ITAB       = TABLE NUMBER FOR FLASH.
C     NCOMP      = NUMBER OF WELL COMPLETIONS.
C     NC         = NUMBER OF COMPONENTS.
C     NCINPH     = NUMBER OF ALL COMPONENTS IN ALL PHASES.
C     NPH        = NUMBER OF FLUID PHASES.
C     ICINPH     = POSITION NUMBER IN PMD FOR EACH COMPONENT IN EACH PHASE.
C     NHC        = NUMBER OF HYDROCARBON COMPONENTS.
C     NFBUG      = UNIT NUMBER FOR PRINTOUT.
C     INPUT_WGRAD= .TRUE. IF WELL GRADIENT SHOULD NOT BE MODIFIED.
C     CONC(IC)   = INJECTION COMPOSITION FOR WELL.
C     WKH(N)     = WELLBORE CONSTANT FOR WELL COMPLETION N.
C     PCOMP(N)    = PRESSURE IN COMPLETION N.            
C     DELH(N)    = RELATIVE DEPTH OF COMPLETION N.
C     PW         = BOTTOMHOLE PRESSURE FOR WELL.
C     TOTAL_MOB(N)=TOTAL MOBILITY FOR COMPLETION N.
C     ITER       = WELL ITERATION NUMBER.

C  INPUT/OUTPUT:
C     IFLDPNT    = FLUID POINTER FOR FLASH. SHOULD BE IFLINIT ON FIRST CALL.
C                  ALWAYS DOES A STABILITY TEST FOR FIRST CALL.
C     GRAD       = WELLBORE GRADIENT FOR WELL.

C  OUTPUT:
C     SHUT       = .TRUE. IF WELL IS CANNOT FLOW.
C     WELL_COEF(IC,N)=WELL EQN COEFFICIENT FOR COMPONENT IC, COMPLETION N.
C                     DOES NOT INCLUDE WKH TERM.
C-----------------------------------------------------------------------
      
C     SETUP PRESSURE DROP (DELP > 0 FOR INJECTING LAYER)
C     INCLUDES WELLBORE CONSTANT
      DO L = 1,NCOMP
          DELP(L) = WKH(L)*( (PW-PCOMP(L)) + GRAD*DELH(L) )
      END DO

      NINJ = 0
      SHUT = .FALSE.
      DO L = 1,NCOMP
         IF(DELP(L) > ZERO .AND. TOTAL_MOB(L) > ZERO) THEN
            NINJ = NINJ+1
            OPEN(L) = .TRUE.
         ELSE
            OPEN(L) = .FALSE.
            DO IC = 1,NC
               WELL_COEF(IC,L) = ZERO
            END DO
         ENDIF
      END DO

      IF(ITER <= 3 .AND. NEWT == 1) THEN
C        FLASH INJECTION COMPOSITION
         CALL EOS(PW,CONC,SAT,MDEN,DUM,PMD,NCINPH,
     &            .FALSE.,NFBUG,NHC,IFLDPNT,ITAB,NC,NPH,
     &            ICINPH,TWELL,FLZ,FLV,FLK)

C        ADJUST SATURATIONS TO ADD TO ONE
         X = ZERO
         DO IPH = 1,NPH
            X = X + SAT(IPH)
         END DO
         X = ONE/X
         DO IPH = 1,NPH
            SAT(IPH) = SAT(IPH)*X
         END DO

C        SETUP WELLBORE COMPONENT UPSTREAM DENSITY TERMS
         DO IC = 1,NC
            DEN_IC(IC) = ZERO
         END DO
         DO IPH = 1,NPH
            X = SAT(IPH)
            DO IC = 1,NC
               K = ICINPH(IC,IPH)
               IF( K > 0 ) THEN
                  DEN_IC(IC) = DEN_IC(IC) + PMD(K)*X
               ENDIF
            END DO
         END DO

C        UPDATE DENSITY GRADIENT TERM FOR WELLBORE
         IF (.NOT.INPUT_WGRAD) THEN
            X = ZERO
            DO IPH = 1,NPH
               X = X + SAT(IPH)*MDEN(IPH)
            END DO
            GRAD = X*GRAV
         ENDIF
      ENDIF

C     NO LAYERS FLOWING IN RIGHT DIRECTION
      IF(NINJ == 0) THEN
         SHUT = .TRUE.
 
C     SETUP UPSTREAM TOTAL MOBILITIES FOR INJECTING LAYERS
      ELSE
         DO L = 1,NCOMP
            IF(OPEN(L)) THEN
               DO IC = 1,NC
                  WELL_COEF(IC,L) = TOTAL_MOB(L)*DEN_IC(IC)
               END DO
            ENDIF
         END DO
      ENDIF
      END

C*********************************************************************
      SUBROUTINE BRENT_ROOT(X,F,XIN1,FIN1,XIN2,FIN2,DEL)
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      REAL*8 STEP 
      PARAMETER (STEP = ONE-FIVE*TEN_M2)
      REAL*8 X, FIN1, FIN2, XIN1, XIN2, F, DEL
      REAL*8 D, FF1, F1F2, FF2, NUM, DENOM, F1, F2, X1, X2, 
     &       E, DEL2, DELF2       
 
C  DOES INVERSE PARABOLIC INTERPOLATION: X = A + B*F + C*F**2.
C  NEXT ITERATION POINT OCCURS AT VALUE OF F = 0, I.E. A IN ABOVE EQUATION.
C  ASSUMES FIN1 /= 0 AND FIN2 /= 0, AND XIN1 /= XIN2 /= X.
C  ASSUMES F*FIN1 < 0 OR F*FIN2 < 0.
 
C  F =         LATEST ESTIMATE OF FUNCTION USING CURRENT X.
C  XIN1,XIN2 = PREVIOUS X-VALUES.
C  FIN1,FIN2 = PREVIOUS FUNCTION VALUES.
C  DEL =       LATEST INCREMENT IN X VALUE.
 
      F1 = FIN1
      F2 = FIN2
      X1 = XIN1
      X2 = XIN2
C     KEEP ROOT BETWEEN X AND X2
      IF(F*F2 > ZERO) THEN       
         D = X1
         X1 = X2
         X2 = D
         D = F1
         F1 = F2 
         F2 = D
         XIN2 = X
         FIN2 = F
      ELSE
         XIN1 = X
         FIN1 = F
      ENDIF
 
C     DO INTERPOLATION IF SLOPE FROM X1 TO X IS SIMILAR TO SLOPE FROM X TO X2
C     OTHERWISE DO BISECTION
      DEL2 = X2-X
      F1F2 = F1/F2
      FF2 = F/F2
      DELF2 = FF2-ONE
      D = DEL2 * (FF2-F1F2)
      E = (X-X1) * DELF2
      IF( ABS(E+D) < ABS(D*HALF) ) THEN    
         FF1 = F/F1
         NUM = FF1 * ( D*F1F2 + E )
         DENOM = (F1F2-ONE) * DELF2 * (FF1-ONE)
C        NEW ESTIMATE WITHIN BOUNDS
         IF(ABS(NUM) < STEP * ABS(DEL2*DENOM)) THEN     
            DEL = NUM / DENOM
         ELSE
            DEL = STEP * DEL2
         ENDIF
      ELSE
         DEL = HALF * DEL2
      ENDIF
 
      X = X + DEL     ! NEW ESTIMATE
      END

C*********************************************************************
      SUBROUTINE XRATE_PROD1(SEP_TABLE,NCOMP,NC,NPH,ICINPH,NHC,
     &                 NFBUG,SHUT,INPUT_WGRAD,TEMPR,WELL_COMP,
     &                 ELECONS,PCOMP,GRAD,PW,MOB,
     &                 WELL_COEF,QLAYER,BHP_CONTROL,PLIMIT,
     &                 WELL_RESID,WELL_RATE,DQWELLDWP,DQWELLDRP,
     &                 RATE_IN,WELL_CONSTRAINT,NSTAGE,LCROSS,
     &                 WMOL,NCINPH,IFLINIT,WELL_KVAL,
     &                 SEP_TEMP,SEP_PRES,CONVERT_PH,CONVERT_IC,
     &                 ITYPE,PMD,WDEPTH,HCOMP,ISEPTYP,NEWT,IOPEN,PHNAM)
C*********************************************************************
C
C PERFORMS WELL CALCULATES FOR PRODUCTION WELLS
C CALCULATES BOTTOMHOLE PRESSURES FOR WELLS ON RATE CONTROL.  
C CALCULATES RATES FOR WELLS THAT ARE BOTTOMHOLE PRESSURE LIMITED.
C PERFORMS ITERATIONS ON BOTTOMHOLE PRESSURE TO ARRIVE AT CONVERGED PRESSURE.
C
C WELL CAN BE LIMITED BY: (1) COMBINATION OF SURFACE COMPONENT RATES
C                         (2) COMBINATION OF SURFACE PHASE RATES
C                         (3) BOTTOMHOLE PRESSURE
C
C OUTPUT IS: (1) COMPONENT RATES AT EACH COMPLETION (QLAYER).
C            (2) NEW WELLBORE GRADIENT IF NOT CONSTANT (GRAD).
C            (3) TOTAL COMPONENT RATE FOR WELL (WELL_COMP).
C            (4) WELL COEFFICIENTS (WELL_COEF).
C            (5) BOTTOMHOLE PRESSURE (PW).
C            (6) INACTIVE INDICATOR (SHUT).
C            (7) BHP CONTROL INDICATOR (BHP_CONTROL).
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xiter.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NCOMP,NC,NPH,ICINPH($MXCOMP+1,NPH),ISEPTYP,
     &        NHC,NFBUG,BHP_CONTROL,NSTAGE,IFLINIT,NEWT,
     &        SEP_TABLE(NSTAGE),ITYPE,NCINPH,IOPEN(NCOMP)
      LOGICAL SHUT,INPUT_WGRAD,LCROSS
      REAL*4 ELECONS(NCOMP),HCOMP(NCOMP)
      REAL*8 TEMPR,PCOMP(NCOMP),GRAD,PW,WELL_RESID,WELL_RATE,
     &       WELL_COMP(NC),PLIMIT,RATE_IN,WELL_CONSTRAINT(NC),
     &       WELL_COEF($MXCOMP+1,NCOMP),QLAYER($MXCOMP+1,NCOMP),WMOL(NC),
     &       DQWELLDWP,DQWELLDRP(NCOMP),MOB($MXPHASE,NCOMP),
     &       WELL_KVAL($MXCOMP,NSTAGE),SEP_TEMP(NSTAGE),SEP_PRES(NSTAGE),
     &       CONVERT_PH($MXCOMP+1,NPH),CONVERT_IC($MXCOMP+1,NPH),
     &       PMD($MXICPH,NCOMP),WDEPTH
      CHARACTER*$MXCNAM PHNAM($MXPHASE)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER L,IC,K,ITER,NITER,IPH,ICON,I
      PARAMETER (NITER = 50)
      LOGICAL LBRENT,CONVERGE
      REAL*8 X,DELP(NCOMP),TOTAL_MOB(NCOMP),F1,F2,FVAL,P1,P2,DIFF_PW,
     &       DIFF_RATE,RATE,PCOEF,RATE_ERROR,XPW,WELLCON(NC,NCOMP),
     &       HIGH,LOW,Y,WCOEF(NC,NCOMP),QCOEF(NC),QTEMP(NC),DELH(NCOMP),
     &       WKH(NCOMP)
      PARAMETER (HIGH = .75D0)
      PARAMETER (LOW = .25D0)
 
C-----------------------------------------------------------------------
C  INPUT:
C     NCOMP      = NUMBER OF WELL COMPLETIONS.
C     NC         = NUMBER OF COMPONENTS.
C     NPH        = NUMBER OF FLUID PHASES.
C     ICINPH     = POSITION NUMBER IN PMD FOR EACH COMPONENT IN EACH PHASE.
C     NCINPH     = SUM OF NUMBER OF COMPONENTS IN ALL PHASES.
C     NHC        = NUMBER OF HYDROCARBON COMPONENTS.
C     NSTAGE     = NUMBER OF STAGES IN SEPARATOR.
C     NFBUG      = UNIT NUMBER FOR PRINTOUT.
C     INPUT_WGRAD= .TRUE. IF WELL GRADIENT SUPPLIED AS INPUT DATA.
C     TEMPR      = TEMPERATURE FOR FLASH.
C     ELECONS(N) = WELLBORE CONSTANT FOR WELL COMPLETION N.
C     PRES(N)    = PRESSURE IN COMPLETION N.            
C     DELH(N)    = RELATIVE DEPTH OF COMPLETION N.
C     MOB(IPH,N) = MOBILITY OF PHASE IPH FOR COMPLETION N.
C     PW         = BOTTOMHOLE PRESSURE FOR WELL.
C     IFLINIT    = FLUID POINTER FOR INITIAL FLASH STATE.
C     TOL_PW     = CONVERGENCE TOLERANCE FOR WELL PRESSURES.
C     TOL_RATE   = RELATIVE CONVERGENCE TOLERANCE FOR RATE CONSTRAINT EQN.
C     PLIMIT     = LIMITING PRESSURE FOR RATE CONSTRAINTED WELLS.
C     RATE_IN    = RATE CONSTRAINT FOR WELL.
C     WELL_CONSTRAINT(IC)=CONSTRAINT MULTIPLIER FOR COMPONENT IC.
C     LCROSS     = TRUE IF CROSSFLOW ALLOWED.
C     WMOL(IC)   = MOLECULAR WEIGHT OF COMPONENT IC.
C     SEP_TABLE(I) = EOS TABLE ASSIGNMENT FOR STAGE I.
C     SEP_PRES(I)=PRESSURE FOR STAGE I.
C     SEP_TEMP(I)=TEMPERATURE FOR STAGE I.
C     ITYPE      = 1, SURFACE PHASE RATE CONSTRAINT
C                  2, SURFACE COMPONENT RATE CONSTRAINT
C                  3, VOLUMETRIC RATE CONSTRAINT 
C     PMD(K,N)   = MOLE FRACTION X MOLAR DENSITY IN COMPLETION N.
C     NEWT       = GLOBAL NEWTONIAN ITERATION.

C  INPUT/OUTPUT:
C     GRAD       = WELLBORE GRADIENT FOR WELL.
C     BHP_CONTROL= 1 IF WELL ON RATE CONTROL.
C                  0 IF WELL BHP LIMITED.
C                 -1 IF WELL ON BHP CONTROL
C     IFLSH(I) = FLASH TYPE FOR STAGE I.

C  OUTPUT:
C     SHUT       = .TRUE. IF WELL IS CANNOT FLOW.
C     WELL_COMP(IC)=COMPONENT RATES FOR WELL.
C     WELL_COEF(IC,N)=WELL EQN COEFFICIENT FOR COMPONENT IC, COMPLETION N.
C                     INCLUDES WKH TERM WHEN EXITING ROUTINE.
C     QLAYER(IC,N)= COMPONENT RATES FOR COMPLETION N.
C     WELL_RESID = RESIDUAL FOR WELL CONSTRAINT EQN.
C     WELL_RATE =  WELL RATE FOR CONSTRAINT EQUATION
C     DQWELLDWP =  PW COEFFICIENT IN WELL CONSTRAINT EQN.
C     DQWELLDRP(N)=PRESSURE COEFFICIENTS IN WELL CONSTRAINT EQN.
C     WELL_KVAL(IC,I) = K-VALUE FOR HYDROCARBON COMPONENT IC, STAGE I.
C     CONVERT_PH(IC,IPH) = PHASE CONVERSION FACTOR FOR 
C                          COMPONENT IC, PHASE IPH. 
C     CONVERT_IC(IC,IPH) = COMPONENT CONVERSION FACTOR FOR 
C                          COMPONENT IC, PHASE IPH. 
C-----------------------------------------------------------------------


C     INITIALIZE WELL TERMS
      IF(NEWT == 1) THEN
         DO L = 1,NCOMP
            IF(ELECONS(L) > ZERO) THEN
               IOPEN(L) = -1
            ELSE
               IOPEN(L) = 0
            ENDIF
         END DO
      ENDIF
      WELL_RESID = ZERO
      WELL_RATE = ZERO
      DO IC = 1,NC
         WELL_COMP(IC) = ZERO
      END DO
      DO L = 1,NCOMP
         DO IC = 1,NC
            QLAYER(IC,L) = ZERO
            WELL_COEF(IC,L) = ZERO
         END DO
      END DO
      DO L = 1,NCOMP
         DQWELLDRP(L) = ZERO
         DELH(L) = HCOMP(L)-WDEPTH
         IF(IOPEN(L) /= 0) THEN
            WKH(L) = CWKH * ELECONS(L)
         ELSE
            WKH(L) = ZERO
         ENDIF
      END DO
      DQWELLDWP = ZERO
      IF(BHP_CONTROL == 1) BHP_CONTROL = 0
 
C     SET UP TOTAL WELL MOBILITY
C     CHECK THAT AT LEAST ONE LAYER IS AVAILABLE FOR FLOW
      K = 0
      DO L = 1,NCOMP
         IF(IOPEN(L) < 0) THEN
            X = ZERO
            DO IPH = 1,NPH
               X = X + MOB(IPH,L)
            END DO
            TOTAL_MOB(L) = X
            IF(X > ZERO) K = 1
         ELSE
            TOTAL_MOB(L) = ZERO
         ENDIF
      END DO
      IF(K == 0) RETURN

C     SETUP COEFFICIENTS ASSUMING ALL LAYERS ARE PRODUCING
      DO L = 1,NCOMP
         IF(TOTAL_MOB(L) <= 0) CYCLE
         DO IC = 1,NC
            WELLCON(IC,L) = ZERO
         END DO
         DO IPH = 1,NPH
            X = MOB(IPH,L)
            IF(X <= ZERO) CYCLE
            DO IC = 1,NC
               K = ICINPH(IC,IPH)
               IF( K > 0) THEN
                  WELLCON(IC,L) = WELLCON(IC,L) + PMD(K,L)*X
               ENDIF
            END DO
         END DO 
      END DO 

C     SET INITIAL PW SO AT LEAST ONE LAYER PRODUCES
C     FOR RATE CONTROLLED WELLS SET LIMITS ON PW. REQUIRES P1 <= PW <= P2
      IF(BHP_CONTROL == 0) THEN
         P2 = -BIG
         P1 = PLIMIT
         K = 0
         DO L = 1,NCOMP
            IF(TOTAL_MOB(L) <= ZERO) CYCLE
            IF(PW - PCOMP(L) + GRAD*DELH(L) < ZERO) K = 1
C           ASSUME GRAD = 0
            IF(DELH(L) >= ZERO) THEN
               P2 = MAX(P2,PCOMP(L))
C           ASSUME GRAD = 1
            ELSE
               P2 = MAX(P2,PCOMP(L)-DELH(L))
            ENDIF
         END DO
         IF(P1 > P2) RETURN
         PW = MAX(P1,MIN(P2,PW))
       
C        FIND PW THAT PRODUCES FROM AT LEAST ONE LAYER
         IF(K == 0) THEN
            PW = MAX(P2 - TEN_P2, P1)
            DO I = 1,11 
               K = 0
               DO L = 1,NCOMP
                  IF(TOTAL_MOB(L) <= ZERO) CYCLE
                  IF(PW - PCOMP(L) + GRAD*DELH(L) < ZERO) K = 1
               END DO
               IF(K /= 0) EXIT
               PW = MAX(PW - TEN_P2, P1)
               IF(I == 10) PW = P1
            END DO
            IF(K == 0) RETURN
         ENDIF
C         WRITE(NFBUG,'(A,F15.5,F15.8)') ' PW,GRAD ',PW,GRAD
C         WRITE(NFBUG,'(A,F15.5,F15.8)') ' P1,P2 ',P1,P2

C     BHP PRESCRIBED
      ELSE
         K = 0
         DO L = 1,NCOMP
            IF(TOTAL_MOB(L) <= ZERO) CYCLE
            IF(PW - PCOMP(L) + GRAD*DELH(L) < ZERO) K = 1
         END DO
         IF(K == 0) RETURN
      ENDIF

C     SURFACE COMPONENT RATE CONSTRAINT
      IF(ITYPE == 2) THEN    
         DO IC = 1,NC
            QCOEF(IC) = WELL_CONSTRAINT(IC)
         END DO
      ENDIF

C-----------------------------------------------------------------------
C           BEGIN ITERATIONS
C-----------------------------------------------------------------------

C     DEFINE FVAL = RATE_IN - RATE FOR PREVIOUS ITERATION
C     FIRST SEVERAL NONZERO RATE ESTIMATES USE CONSTRAINT EQUATION TO GET PW
C     BISECTION USED FOR LATER ITERATIONS IF PW NOT BOUNDED
C     QUADRATIC INTERPOLATION USED TO GET PW ONCE SOLUTION IS BOUNDED
      ICON = 0
      LBRENT = .FALSE.
      DO ITER = 1,NITER
C         WRITE(NFBUG,'(A,I5)') ' ITERATION ',ITER

C        DETERMINE WELL COEFFICIENTS, CROSSFLOW, GRAD, SHUT VALUES
         CALL XRATE_PROD2(NCOMP,NC,WELLCON,SHUT,INPUT_WGRAD,
     &                    WKH,PCOMP,DELH,GRAD,PW,TOTAL_MOB,
     &                    WCOEF,LCROSS,WMOL,ITER,QTEMP,NEWT)
C         WRITE(NFBUG,'(A,F15.8)') '    GRAD ',GRAD

C        SET UP K VALUES FOR WELL
         IF(ITER == 1 .AND. ISEPTYP == 0 .AND. NEWT == 1) THEN
            CALL SET_KVAL(NC,NHC,NPH,NCINPH,ICINPH,IFLINIT,SEP_TABLE, 
     &                    NFBUG,WELL_KVAL,QTEMP,SEP_PRES,NSTAGE,
     &                    SEP_TEMP)
         ENDIF

C        SET UP SURFACE CONVERSION FACTORS
         CALL CALC_CONVERT_PH(NC,NPH,NHC,QTEMP,SEP_PRES,NSTAGE, 
     &                       WELL_KVAL,SEP_TABLE,SEP_TEMP,CONVERT_PH,
     &                       CONVERT_IC,PHNAM)

C        SURFACE PHASE RATE CONSTRAINT
         IF(ITYPE == 1) THEN  
            DO IC = 1,NC
               X = ZERO
               DO IPH = 1,NPH
                  X = X + WELL_CONSTRAINT(IC)*CONVERT_PH(IC,IPH)
               END DO
               QCOEF(IC) = X
            END DO
         ENDIF
      
C        SETUP PRESSURE DROP (DELP < 0 FOR PRODUCING LAYER)
C        INCLUDES WELLBORE CONSTANT
         IF(SHUT) THEN
            RATE_ERROR = RATE_IN
            RATE = ZERO
            PCOEF = ONE
         ELSE
            DO L = 1,NCOMP
               DELP(L) = WKH(L)*((PW-PCOMP(L))+GRAD*DELH(L))
C               WRITE(NFBUG,'(A,I5,F15.5)') '    DELP ',L,DELP(L)
            END DO
            RATE = ZERO
            PCOEF = ZERO

C           SURFACE PHASE RATE OR SURFACE COMPONENT CONSTRAINT
            IF(ITYPE <= 2) THEN  
               DO L = 1,NCOMP
                  IF(TOTAL_MOB(L) <= ZERO) CYCLE
                  X = ZERO
                  DO IC = 1,NC
                     X = X + WCOEF(IC,L)*QCOEF(IC)
                  END DO
                  PCOEF = PCOEF + WKH(L)*X
                  RATE = RATE + DELP(L)*X
               END DO
 
C           RESERVOIR RATE CONSTRAINT
            ELSEIF(ITYPE == 3) THEN
               DO L = 1,NCOMP
                  IF(TOTAL_MOB(L) <= ZERO) CYCLE
                  PCOEF = PCOEF + FT_TO_BBL*TOTAL_MOB(L) * WKH(L)
                  RATE = RATE + FT_TO_BBL*TOTAL_MOB(L) * DELP(L)
               END DO
            ENDIF
            RATE_ERROR = RATE_IN - RATE
         ENDIF
C         WRITE(NFBUG,'(A,F15.5,F15.8)') '    RATE,RATE_ERROR ',RATE,
C     &                                       RATE_ERROR

C-----------------------------------------------------------------------
C        PRESSURE SPECIFIED WELL
C-----------------------------------------------------------------------
         IF(BHP_CONTROL == -1) THEN
            IF(RATE <= ZERO) THEN
               CONVERGE = .TRUE.
               EXIT
            ELSE
               RETURN
            ENDIF

C-----------------------------------------------------------------------
C        PRESSURE LIMITED WELL
C-----------------------------------------------------------------------
         ELSEIF(PCOEF <= ZERO) THEN
C            WRITE(NFBUG,'(A)') '    PCOEF ZERO '
            IF(PW == PLIMIT) THEN
               DO IC = 1,NC
                  QTEMP(IC) = ZERO
               END DO
               DO L = 1,NCOMP
                  IF(TOTAL_MOB(L) <= ZERO) CYCLE
                  DO IC = 1,NC
                     QTEMP(IC) = QTEMP(IC) + WCOEF(IC,L)*DELP(L)
                  END DO
               END DO
               K = 0
               DO IC = 1,NC
                  IF(QTEMP(IC) > ZERO) K = 1
               END DO
               IF(K == 1) RETURN
            ENDIF
            XPW = PLIMIT
            DIFF_PW= ABS(PW - XPW)

         ELSEIF(PW == PLIMIT) THEN
C            WRITE(NFBUG,'(A)') '    BHP LIMITED '
            IF(SHUT) RETURN
            XPW = PW + RATE_ERROR/PCOEF
            XPW = MAX(PLIMIT,MIN(XPW,HALF*(P1+P2)))
            DIFF_PW= ABS(PW - XPW)

C-----------------------------------------------------------------------
C        RATE LIMITED WELL
C-----------------------------------------------------------------------
         ELSE

C           ESTIMATE RATE ERROR
C           PW TOO LOW IF RATE_ERROR > 0
            DIFF_RATE = ABS(RATE_ERROR)
CGUS FIX FOR RATE SPECIFIED PRODUCTION WELLS
C            IF( DIFF_RATE <= ABS(TOL_RATE*RATE_IN)) THEN
C               CONVERGE = .TRUE.
C               EXIT
C            ENDIF

C           NO PRODUCTION OF CONSTRAINT FLUID
            IF(RATE == ZERO) THEN 
C               WRITE(NFBUG,'(A)') '    RATE == ZERO'
               IF(PW == PLIMIT) THEN
                  IF(SHUT) RETURN
                  EXIT
               ENDIF
               P2 = PW
               X = TEN*ITER
               XPW = MAX(P1,PW-X)
               DIFF_PW = BIG
 
C           ESTIMATE PW USING QUADRATIC INTERPOLATION
C           ONLY DOES BRENT IF SOLUTION HAS BEEN BOUNDED
            ELSEIF(LBRENT) THEN 
C               WRITE(NFBUG,'(A)') '    BRENT '
               XPW = PW
C              GET NEW ESTIMATE XPW AND RESET P1 OR P2 TO MAINTAIN BOUND
               CALL BRENT_ROOT(XPW,RATE_ERROR,P1,F1,P2,F2,DIFF_PW)
               DIFF_PW = ABS(DIFF_PW)
               IF(XPW > PW) THEN
                  P1 = PW
               ELSE
                  P2 = PW
               ENDIF
 
C           ESTIMATE PW USING BISECTION OR SET BOUNDS
C           ICON IS NUMBER OF CONSTRAINT ESTIMATES
            ELSEIF(ICON > 3) THEN
               IF(RATE_ERROR >= ZERO) THEN
                  P1 = PW
               ELSE
                  P2 = PW
               ENDIF
 
C              ROOT IS BOUNDED BETWEEN AND PW
               IF(RATE_ERROR*FVAL < ZERO) THEN
C                  WRITE(NFBUG,'(A)') '    SET BOUNDS'
                  IF(PW == P2) THEN 
                     F1 = FVAL
                     F2 = RATE_ERROR
                  ELSE
                     F2 = FVAL
                     F1 = RATE_ERROR
                  ENDIF
                  IF(ABS(F1) > ABS(F2)) THEN
                     XPW = LOW*P1 + HIGH*P2
                  ELSE
                     XPW = HIGH*P1 + LOW*P2
                  ENDIF
                  LBRENT = .TRUE.
 
C              SOLUTION NOT BOUNDED YET
               ELSE
C                  WRITE(NFBUG,'(A)') '    BISECTION'
                  XPW = HALF*(P1+P2)
               ENDIF  
   
C           PREDICT PW USING CONSTRAINT EQUATION
C           ALWAYS COMES HERE FOR FIRST ITERATION WHERE RATE /= ZERO
C           UNLESS PRESSURE LIMITED
            ELSE
C               WRITE(NFBUG,'(A)') '    USE CONSTRAINT EQUATION'
               ICON = ICON + 1
               IF(RATE_ERROR >= ZERO) THEN
                  P1 = PW
               ELSE
                  P2 = PW
               ENDIF
               XPW = PW + RATE_ERROR/PCOEF
               IF(XPW < P1) THEN
                  XPW = P1
                  ICON = 100
               ELSEIF(XPW > P2) THEN
                  XPW = P2
                  ICON = 100
               ENDIF
            ENDIF
            DIFF_PW = ABS(XPW-PW)
         ENDIF
 
         PW = XPW
C         WRITE(NFBUG,'(A,F15.5)') '    NEW PW ESTIMATE ',PW
         FVAL = RATE_ERROR
         IF(DIFF_PW <= TOL_PW
CGUS FIX FOR RATE SPECIFIED PRODUCTION WELLS
     &      .AND.DIFF_RATE <= ABS(TOL_RATE*RATE_IN)) THEN
            CONVERGE = .TRUE.
            EXIT
         ENDIF
      END DO 
C-----------------------------------------------------------------------
C     FINISH PROCESSING WELL
C-----------------------------------------------------------------------
      IF(BHP_CONTROL /= -1) THEN
         IF(ABS(PW-PLIMIT) < TOL_PW) THEN
            PW = PLIMIT
C            WRITE(NFBUG,'(A)') '    WELL IS ON BHP CONTROL'
         ELSE
C            WRITE(NFBUG,'(A)') '    WELL IS ON RATE CONTROL'
           BHP_CONTROL = 1
         ENDIF
      ENDIF
      DO L = 1,NCOMP
         DO IC = 1,NC
            WELL_COEF(IC,L) = WKH(L) * WCOEF(IC,L)
         END DO
      END DO

      DO IC = 1,NC
         WELL_COMP(IC) = ZERO
      END DO
      WELL_RATE = ZERO
      PCOEF = ZERO

C     SURFACE PHASE RATE OR COMPONENT CONSTRAINT
      IF(ITYPE <= 2) THEN  
         DO L = 1,NCOMP
            X = ZERO
            Y = PW+GRAD*DELH(L)-PCOMP(L)
            IF(Y < ZERO) THEN
               IF(IOPEN(L) > 0) IOPEN(L) = 0
            ELSEIF(NEWT == 1) THEN
               IOPEN(L) = 1
            ELSE
               IF(IOPEN(L) < 0) IOPEN(L) = 0
            ENDIF 
            DO IC = 1,NC
               X = X + WELL_COEF(IC,L)*QCOEF(IC)
               QLAYER(IC,L) = WELL_COEF(IC,L)*Y
               WELL_COMP(IC) = WELL_COMP(IC) + QLAYER(IC,L)
            END DO
            DQWELLDRP(L) = -X
            PCOEF = PCOEF + X
            WELL_RATE = WELL_RATE + X*Y
         END DO
 
C     RESERVOIR RATE CONSTRAINT
      ELSEIF(ITYPE == 3) THEN
         DO L = 1,NCOMP
            Y = PW+GRAD*DELH(L)-PCOMP(L)
            IF(Y < ZERO) THEN
               IF(IOPEN(L) > 0) IOPEN(L) = 0
            ELSEIF(NEWT == 1) THEN
               IOPEN(L) = 1
            ELSE
               IF(IOPEN(L) < 0) IOPEN(L) = 0
            ENDIF 
            DO IC = 1,NC
               QLAYER(IC,L) = WELL_COEF(IC,L)*Y
               WELL_COMP(IC) = WELL_COMP(IC) + QLAYER(IC,L)
            END DO
            X = FT_TO_BBL*TOTAL_MOB(L) * WKH(L)
            DQWELLDRP(L) = -X
            PCOEF = PCOEF + X
            WELL_RATE = WELL_RATE + X*Y
         END DO
      ENDIF
      DQWELLDWP = PCOEF
      WELL_RESID = RATE_IN - WELL_RATE

      END 

C*********************************************************************
      SUBROUTINE XRATE_PROD2(NCOMP,NC,WELLCON,SHUT,INPUT_WGRAD,WKH,
     &                       PCOMP,DELH,GRAD,PW,TOTAL_MOB,WELL_COEF,
     &                       LCROSS,WMOL,ITER,QCOMP,NEWT)
C*********************************************************************
C CALCULATES COMPONENT RATES FOR A PRODUCTION WELL. 
C REQUIRES PW AND ESTIMATE OF WELL GRADIENT.
C
C OUTPUT IS: (1) NEW WELLBORE GRADIENT IF NOT CONSTANT (GRAD).
C            (2) COMPONENT COEFFICIENT FOR WELL TERMS (WELL_COEF).
C            (3) SHUT-IN FLAG (SHUT).
C            (4) WELLBORE DENSITY FOR COMPONENT IC. MUST BE SCALED TO
C                PRODUCE WELL MOLE FRACTION.
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NCOMP,NC,ITER,NEWT
      LOGICAL SHUT,INPUT_WGRAD,LCROSS
      REAL*8 PCOMP(NCOMP),DELH(NCOMP),GRAD,PW,WMOL(NC),QCOMP(NC),
     &       TOTAL_MOB(NCOMP),WELL_COEF(NC,NCOMP),WELLCON(NC,NCOMP),
     &       WKH(NCOMP)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER L,IC,NPROD,KOPEN(NCOMP)
      REAL*8 X,DELP(NCOMP),QT,GRAV,DEN(NC)
      PARAMETER (GRAV = .006944445D0)
C-----------------------------------------------------------------------
C  INPUT:
C     NCOMP      = NUMBER OF WELL COMPLETIONS.
C     NC         = NUMBER OF COMPONENTS.
C     INPUT_WGRAD= .TRUE. IF WELL GRADIENT SHOULD NOT BE MODIFIED.
C     WKH(N)     = WELLBORE CONSTANT FOR WELL COMPLETION N.
C     PCOMP(N)    = PRESSURE IN COMPLETION N.            
C     DELH(N)    = RELATIVE DEPTH OF COMPLETION N.
C     PW         = BOTTOMHOLE PRESSURE FOR WELL.
C     TOTAL_MOB(N)=TOTAL MOBILITY FOR COMPLETION N.
C     LCROSS     = .TRUE. IF CROSSFLOW ALLOWED FOR WELL.
C     WMOL(IC)   = MOLECULAR WEIGHT OF COMPONENT IC.
C     ITER       = WELL ITERATION NUMBER.
C     WELLCON(IC,N) = PRODUCTION COEFFICIENT FOR COMPONENT IC, COMPLETION N.

C  INPUT/OUTPUT:
C     GRAD       = WELLBORE GRADIENT FOR WELL.

C  OUTPUT:
C     SHUT       = .TRUE. IF WELL IS CANNOT FLOW.
C     WELL_COEF(IC,N)=WELL EQN COEFFICIENT FOR COMPONENT IC, COMPLETION N.
C                     DOES NOT INCLUDE WKH TERM.
C-----------------------------------------------------------------------
      
C     SETUP PRESSURE DROP (DELP > 0 FOR INJECTING LAYER)
C     INCLUDES WELLBORE CONSTANT
      DO L = 1,NCOMP
          DELP(L) = WKH(L)*( (PW-PCOMP(L)) + GRAD*DELH(L) )
      END DO

      NPROD = 0
      SHUT = .FALSE.
      DO L = 1,NCOMP
         DO IC = 1,NC
            WELL_COEF(IC,L) = ZERO
         END DO
         IF(TOTAL_MOB(L) == ZERO) THEN
            KOPEN(L) = 0
         ELSEIF(DELP(L) <= ZERO) THEN
            NPROD = NPROD+1
            KOPEN(L) = -1
         ELSE
            KOPEN(L) = 1
         ENDIF
      END DO

C     NO LAYERS FLOWING IN RIGHT DIRECTION
C     ESTIMATE GRAD USING MOBILITY TERM IF FLOW DIRECTION WRONG
      IF(NPROD == 0) THEN
         SHUT = .TRUE.
      ENDIF

C     SETUP COEFFICIENTS FOR PRODUCING LAYERS AND DETERMINE RATES
      DO IC = 1,NC
         QCOMP(IC) = ZERO
      END DO
      QT = ZERO
      IF(SHUT) THEN
         DO L = 1,NCOMP
            QT = QT + TOTAL_MOB(L)
            DO IC = 1,NC
               QCOMP(IC) = QCOMP(IC) + WELLCON(IC,L)
            END DO 
         END DO 
      ELSE
         DO L = 1,NCOMP
            IF(KOPEN(L) >= 0) CYCLE
            QT = QT + TOTAL_MOB(L)*DELP(L)
            DO IC = 1,NC
               WELL_COEF(IC,L) = WELLCON(IC,L)
               QCOMP(IC) = QCOMP(IC) + WELL_COEF(IC,L)*DELP(L)
            END DO 
         END DO 
      ENDIF
        
C     SETUP WELLBORE DENSITY 
      QT = ONE / QT
      DO IC = 1,NC
         DEN(IC) = QCOMP(IC)*QT
      END DO
 
C     SETUP UPSTREAM TOTAL MOBILITIES FOR INJECTING LAYERS
      IF(LCROSS .AND. .NOT.SHUT) THEN
         DO L = 1,NCOMP
            IF(KOPEN(L) > 0) THEN
               DO IC = 1,NC
                  WELL_COEF(IC,L) = TOTAL_MOB(L)*DEN(IC)
               END DO
            ENDIF
         END DO
      ENDIF
 
C     UPDATE DENSITY GRADIENT TERM FOR WELLBORE
      IF (ITER <= 3 .AND. .NOT.INPUT_WGRAD .AND. NEWT == 1) THEN
         X = DEN(1)*WATMOLW
         DO IC = 2,NC
            X = X + DEN(IC)*WMOL(IC-1)
         END DO
         GRAD = X*GRAV
      ENDIF
      END

C*********************************************************************
      SUBROUTINE SET_KVAL(NC,NHC,NPH,NCINPH,ICINPH,IFLINIT,SEP_TABLE, 
     &                    NFBUG,WELL_KVAL,QCOMP,SEP_PRES,NSTAGE,
     &                    SEP_TEMP)
C*********************************************************************
C PERFORMS FLASH TO FIND K-VALUES  SEPARATOR STAGES.
C PUTS K-VALUES INTO WELL_KVAL VARIABLE.
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NC,NPH,NSTAGE,NHC,NFBUG,IFLINIT,NCINPH,
     &        SEP_TABLE(NSTAGE)
      INTEGER ICINPH($MXCOMP+1,NPH)
      REAL*8 WELL_KVAL($MXCOMP,NSTAGE),QCOMP(NC),SEP_PRES(NSTAGE),
     &       SEP_TEMP(NSTAGE)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER IC,I,J,IFLSH
      REAL*8 DENL,DENV,Z(NC),X(NC),Y(NC)
      REAL*8 PMD(NC*NPH),DUM,DUMC(NC),ZMIN,PRES,TEMPR,V
 
C     FOLLOWING VARIABLES FOR FLASH
      REAL*8  FLZ(3),FLV(2),FLK($MXCOMP)
C-----------------------------------------------------------------------
C  INPUT:
C     NC      = NUMBER OF COMPONENTS.
C     NHC     = NUMBER OF HYDROCARBON COMPONENTS.
C     NPH     = NUMBER OF FLUID PHASES.
C     NSTAGE  = NUMBER OF STAGES IN SEPARATOR TRAIN.
C     SEP_TABLE(I) = EOS TABLE ASSIGNMENT FOR STAGE I.
C     SEP_PRES(I)=PRESSURE FOR STAGE I.
C     SEP_TEMP(I)=TEMPERATURE FOR STAGE I.
C     ICINPH  = POSITION NUMBER IN PMD FOR EACH COMPONENT IN EACH PHASE.
C     NCINPH  = SUM OF NUMBER OF COMPONENTS IN ALL PHASES.
C     QCOMP(IC)= COMPONENT RATE FOR WELL.
C     NFBUG   = UNIT NUMBER FOR PRINTOUT.

C  OUTPUT:
C     WELL_KVAL(IC,I) = K-VALUE FOR HYDROCARBON COMPONENT IC, STAGE I.
 
      ZMIN = TEN_M15
 
C     SET COMPOSITION FOR FIRST STAGE OF SEPARATOR, Z IS MOLAR RATE
C     SET PRESSURE FOR FLASH
      Z(1) = ZERO
      DO IC = 2,NC
         X(IC) = MAX(ABS(QCOMP(IC)),ZMIN)
      END DO
 
C--------------------------------------------------------------------------        
C     LOOP OVER ALL STAGES
C-------------------------------------------------------------------------- 
  
      DO I = 1,NSTAGE
         IFLSH = IFLINIT
         PRES = SEP_PRES(I)
         TEMPR = SEP_TEMP(I)
         DO IC = 2,NC
            Z(IC) = X(IC)
         END DO
C
C        FLASH THIS STAGE OF SEPARATOR
         CALL EOS(PRES,Z,DUMC,DUMC,DUMC,PMD,NCINPH,.FALSE., 
     &            NFBUG,NHC,IFLSH,SEP_TABLE(I),NC,NPH,
     &            ICINPH,TEMPR,FLZ,FLV,FLK)
         V = FLV(1)

C        ALL VAPOR
         IF(V >= ONE) THEN
            DO J = I,NSTAGE
               DO IC = 1,NHC
                  WELL_KVAL(IC,J) = TWO
               END DO
            END DO
            EXIT
         ELSEIF(V <= ZERO) THEN
            DO IC = 2,NC
               X(IC) = Z(IC)
               WELL_KVAL(IC-1,I) = HALF
            END DO
         ELSE
            DO IC = 2,NC
               J = IC-1
               X(IC) = Z(IC) / (ONE + (FLK(J)-ONE)*V)
               X(IC) = MAX(ZMIN,X(IC))
               WELL_KVAL(J,I) = FLK(J)
            END DO
         ENDIF
      END DO
      END

C*********************************************************************
      SUBROUTINE CALC_CONVERT_PH(NC,NPH,NHC,QCOMP,SEP_PRES,NSTAGE, 
     &                WELL_KVAL,SEP_TABLE,SEP_TEMP,CONVERT_PH,
     &                CONVERT_IC,PHNAM)
C*********************************************************************
C CALCULATES CONVERT_PH AND CONVERT_IC FOR SURFACE SEPARATORS. 
C ASSUMES K-VALUES ARE CONSTANT.
C EXPRESSION FOR PHASE RATE IS:

C         QPHASE(IPH) = CONVERT_PH(1,IPH) * QCOMP(1)  
C                     + CONVERT_PH(2,IPH)  * QCOMP(2)  
C                     +     ...            *    ...       
C                     + CONVERT_PH(NC,IPH) * QCOMP(NC)

C WHERE QCOMP(I,IC) IS COMPONENT RATE IC IN LB-MOLES.  CONVERT_PH BASED
C UPON EXPANSION OF JACOBIAN THROUGH SEPARATOR STAGES.
C EXPRESSION FOR COMPONENT RATE IN A PHASE IS:

C         Q(IC,IPH) = CONVERT_IC(IC,IPH)  * QCOMP(IC) 

C USES SIMPLIFIED APPROXIMATION FOR CONVERT_IC. MAY NEED TO REPLACE
C CONVERT_IC WITH EXPANSION OF JACOBIAN IF CONVERT_IC USED FOR CONSTRAINTS.
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
      INCLUDE 'xiter.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER NC,NPH,NSTAGE,NHC,SEP_TABLE(NSTAGE)
      REAL*8 CONVERT_PH($MXCOMP+1,NPH),CONVERT_IC($MXCOMP+1,NPH),QCOMP(NC),
     &       WELL_KVAL($MXCOMP,NSTAGE),SEP_TEMP(NSTAGE),SEP_PRES(NSTAGE)
      CHARACTER*$MXCNAM PHNAM($MXPHASE)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      LOGICAL LIQUID_WEL
      INTEGER IC,I,JC,IPH
      REAL*8 X,Z(NHC),VF(NSTAGE),LF(NSTAGE),XDZ(NHC,NSTAGE),
     &       DRDV(NSTAGE),ZF,DUM,DLDM(NHC),AD(NHC),AP,BP,CP,PRLOG,
     &       DVDM(NHC),CONV_IC(NHC),X1,X2,XDRDV,Y,TEMPR
C-----------------------------------------------------------------------
C  INPUT:
C     NC         = NUMBER OF COMPONENTS.
C     NHC     = NUMBER OF HYDROCARBON COMPONENTS.
C     NPH        = NUMBER OF FLUID PHASES.
C     NSTAGE = NUMBER OF STAGES IN A SEPARATOR TRAIN.
C     WELL_KVAL(IC,I) = K-VALUE FOR HYDROCARBON COMPONENT IC, STAGE I.
C     SEP_PRES(I,J) = PRESSURE FOR STAGE I.
C     SEP_TEMP(I) = TEMPERATURE FOR STAGE I.
C     SEP_TABLE(I) = TABLE ASSIGNMENT FOR STAGE I.
C     QCOMP(IC) = COMPONENT RATES FOR WELL.
C
C  OUTPUT:
C     CONVERT_PH(IC,IPH) = PHASE CONVERSION FACTOR FOR 
C                          COMPONENT IC, PHASE IPH. 
C     CONVERT_IC(IC,IPH) = COMPONENT CONVERSION FACTOR FOR 
C                          COMPONENT IC, PHASE IPH. 
C-----------------------------------------------------------------------

C     SET COMPOSITION AND PRESSURE FOR FIRST STAGE OF SEPARATOR
C     Z ONLY CONTAINS HYDROCARBON COMPONENTS
      CONVERT_PH(1,1) = FT_TO_BBL/WATDEN
      CONVERT_IC(1,1) = ONE
      DO IPH = 2,NPH
         CONVERT_PH(1,IPH) = ZERO
         CONVERT_IC(1,IPH) = ZERO
      END DO
      DO IC = 2,NC
         CONVERT_PH(IC,1) = ZERO
         CONVERT_IC(IC,1) = ZERO
      END DO
      IF(NPH == 1) RETURN
         
      X = ZERO
      DO IC = 2,NC
         Z(IC-1) = ABS(QCOMP(IC))
         X = X + ABS(QCOMP(IC))
      END DO
      IF(X <= ZERO) THEN
         DO IPH = 2,NPH
            DO IC = 1,NC
               CONVERT_PH(IC,IPH) = ZERO
               CONVERT_IC(IC,IPH) = ZERO
            END DO
         END DO
         RETURN
      ELSE
         X = ONE / X
         DO IC = 1,NHC
            Z(IC) = Z(IC)*X
         END DO
      ENDIF
C
C     FLASH FROM PRIMARY THROUGH ALL SECONDARY STAGES IN A SEPARATOR
      IF(NPH > 2) THEN
         LIQUID_WEL = .TRUE.
         DO I = 1,NSTAGE
            CALL SEP_RR(Z,WELL_KVAL(1,I),VF(I),LF(I),
     &                  XDZ(1,I),DRDV(I),TOL_RR,NHC)
             IF(VF(I) >= ONE) THEN
                LIQUID_WEL = .FALSE.
                EXIT
             ELSE
                DO IC = 1,NHC
                   Z(IC) =  XDZ(IC,I) * Z(IC)
                END DO
             ENDIF
         END DO
      ELSE
         LIQUID_WEL = .FALSE.
      ENDIF

C     COMBINE TERMS WORKING FROM LAST STAGE BACK TO PRIMARY
C     DLDM IS TERM FOR LIQUID CONVERSION
C     DVDM IS TERM FOR VAPOR CONVERSION (CONSTANT FACTOR OF LBMOLE_TO_MCF)
      IF(LIQUID_WEL) THEN

C        FIND PARTIAL MOLAR VOLUME OF LIQUID PHASE AT LAST STAGE (DLDM)
C        SET INITIAL GUESS FOR LIQUID Z-FACTOR
         ZF = TEN_M2 
         CALL EOS_PROP(SEP_PRES(NSTAGE),Z,ZF,DUM,AD,AP,BP,CP,PRLOG,
     &                 SEP_TABLE(NSTAGE),.FALSE.,.FALSE.,TOL_ZFAC,
     &                 NHC,1,1,1,1)
         TEMPR = SEP_TEMP(NSTAGE) + TRF  
         CALL EOS_PROP_DR(SEP_PRES(NSTAGE),ZF,DUM,DLDM,DUM,DUM,AD,
     &                 AP,BP,CP,PRLOG,SEP_TABLE(NSTAGE),TEMPR,1,0,1,0,
     &                 1,1,1,0,.FALSE.,.FALSE.,NHC,1,1,1,1)
         DO IC = 1,NHC
            DVDM(IC) = ONE
            CONV_IC(IC) = ONE
         END DO
         DO I = NSTAGE,1,-1
            X1 = ZERO
            X2 = ZERO
            DO IC = 1,NHC
               X = XDZ(IC,I) * WELL_KVAL(IC,I) * Z(IC)
               X1 = X1 + X * DLDM(IC)
               X2 = X2 + X * DVDM(IC)
                IF(XDZ(IC,I) > 0) THEN
                  Z(IC) = Z(IC) / XDZ(IC,I)
               ELSE
                  Z(IC) = ZERO
               ENDIF
            END DO
            XDRDV = ONE / DRDV(I)
            Y = LF(I)
            DO IC = 1,NHC
               X = XDRDV * (WELL_KVAL(IC,I) - ONE)
               CONV_IC(IC) = XDZ(IC,I) * Y * CONV_IC(IC)
               DLDM(IC) = XDZ(IC,I) * (Y * DLDM(IC) + X * X1)
               DVDM(IC) = XDZ(IC,I) * (Y * DVDM(IC) + X * X2)
            END DO
         END DO  

         DO IC = 2,NC    
            JC = IC - 1
            CONVERT_PH(IC,2) = FT_TO_BBL * DLDM(JC)
            CONVERT_PH(IC,3) = LBMOLE_TO_MCF * ( ONE - DVDM(JC) )
            CONVERT_IC(IC,2) = CONV_IC(JC)
            CONVERT_IC(IC,3) = ONE - CONV_IC(JC)
         END DO

C     ONLY WATER AND SINGLE HYDROCARBON PHASE ALLOWED
      ELSEIF(NPH == 2) THEN
         IF(PHNAM(2) == 'OIL') THEN

C           FIND PARTIAL MOLAR VOLUME OF LIQUID PHASE AT LAST STAGE (DLDM)
C           SET INITIAL GUESS FOR LIQUID Z-FACTOR
            ZF = TEN_M2 
            CALL EOS_PROP(SEP_PRES(NSTAGE),Z,ZF,DUM,AD,AP,BP,CP,PRLOG,
     &                    SEP_TABLE(NSTAGE),.FALSE.,.FALSE.,TOL_ZFAC,
     &                    NHC,1,1,1,1)
            TEMPR = SEP_TEMP(NSTAGE) + TRF  
            CALL EOS_PROP_DR(SEP_PRES(NSTAGE),ZF,DUM,DLDM,DUM,DUM,AD,
     &                  AP,BP,CP,PRLOG,SEP_TABLE(NSTAGE),TEMPR,1,0,1,0,
     &                  1,1,1,0,.FALSE.,.FALSE.,NHC,1,1,1,1)

            DO IC = 2,NC    
               CONVERT_PH(IC,2) = FT_TO_BBL * DLDM(IC-1)
               CONVERT_IC(IC,2) = ONE
            END DO
         ELSE
            DO IC = 2,NC
               CONVERT_PH(IC,2) = LBMOLE_TO_MCF
               CONVERT_IC(IC,2) = ONE
            END DO
         ENDIF

C     THREE-PHASE WELL DOES NOT PRODUCE ANY LIQUID HYDROCARBONS
      ELSE
         DO IC = 2,NC
            CONVERT_PH(IC,2) = ZERO
            CONVERT_PH(IC,3) = LBMOLE_TO_MCF
            CONVERT_IC(IC,2) = ZERO
            CONVERT_IC(IC,3) = ONE
         END DO
      ENDIF
      END 

C*********************************************************************
      SUBROUTINE SEP_RR(Z,EK,V,LIQ,XDZ,SBINV,TOLRR,NHC)
C*********************************************************************
C SOLVE RACHFORD-RICE EQUATION WITH LIMITED NEWTON-RAPHSON.
C INCLUDES SPECIAL LOGIC FOR SETTING PARAMETERS FOR SEPARATOR CALCULATIONS.
C ALLOWS ALL Z(IC) VALUES TO BE ZERO (ASSUMES SINGLE PHASE VAPOR FOR THIS CASE).
C VMID CHOSEN NEAR 1 TO AVOID EXTRA CALCULATIONS FOR 1-V SOLUTION.
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C------------------------------------------------------------------------
C     Dummy Arguments
C------------------------------------------------------------------------
      INTEGER NHC
      REAL*8 TOLRR,Z(NHC),EK(NHC),XDZ(NHC),V,SBINV,LIQ 
C------------------------------------------------------------------------
C     Local Arguments
C------------------------------------------------------------------------
      INTEGER IC,ITER,ITMAX
      REAL*8 A(NHC),VMAX,VMIN,RR,XDZ_VAL(NHC),SBINV_VAL,R0,DELV,
     &       B(NHC),RR_OLD,LMIN,LMAX,DELL
      REAL*8 VMID,STEP
      PARAMETER (VMID=ONE-FIVE*TEN_M2)
      PARAMETER (STEP=ONE-TEN_M2)
      PARAMETER (ITMAX=50)
C-----------------------------------------------------------------------
C  INPUT:
C     EK(IC) = K_VALUE OF COMPONENT IC.
C     Z(IC)  = OVERALL MOLE FRACTION  OF COMPONENT IC.
C     TOLRR  = TOLERANCE FOR SOLVING RR EQUATION.
C     NHC    = THE NUMBER OF HYDROCARBON COMPONENTS.

C  OUTPUT:
C     V      = THE EQUILIBRIUM VAPOR FRACTION.
C     LIQ    = THE EQUILIBRIUM LIQUID FRACTION.
C     XDZ(IC)= X(IC)/Z(IC)
C     SBINV = THE DERIVATIVE OF RR(L) WITH RESPECT TO V(L).
C-----------------------------------------------------------------------
 
C     INITIALIZE PARAMETERS
C     RR(0) IS CHEAP CALCULATION BECAUSE NO DIVISION INVOLVED
      R0 = ZERO       
      RR = ZERO    
      DO IC = 1, NHC
         A(IC) = ONE - EK(IC)
         R0 = R0 - A(IC) * Z(IC)
         IF(A(IC)/= ZERO)THEN
C          SET A TO 1/(K(IC)-1)
           A(IC) = ONE/A(IC)        
         ELSE
           A(IC) = -BIG
         ENDIF
C        RR = SUM( Z(IC) / (V - A(IC) )
         RR = RR + Z(IC) / (VMID - A(IC))  
      END DO
 
C     SINGLE PHASE 
      IF(R0 <= ZERO) THEN
 
C        ALL (K(IC)-1)*Z(IC) ARE ZERO (TREAT AS VAPOR)
         IF(RR >= ZERO) THEN
            V = ONE
            LIQ = ZERO  
            DO IC = 1,NHC
               XDZ(IC) = ZERO
            END DO
            SBINV = ONE
  
C        ALL LIQUID
         ELSE
            V = ZERO
            LIQ = ONE 
            DO IC = 1,NHC
               XDZ(IC) = ONE
            END DO
C           DR/DV USED IN DENOMINATOR FOR DQ(IC,ISTAGE+1)/DQ(JC,ISTAGE)
            SBINV = BIG        
         ENDIF
 
C     RR(0) > ZERO
C     SOLUTION GREATER THAN VMID  
      ELSEIF(RR > ZERO) THEN
         RR = ZERO
         DO IC = 1,NHC
C           MULTIPLY TO AVOID ROUNDOFF FROM 1 - A(IC)
            B(IC) = A(IC) * EK(IC)            
            RR = RR - Z(IC) / B(IC)    
         END DO
 
C        ALL VAPOR
         IF(RR >= ZERO) THEN
            V = ONE
            LIQ = ZERO   
            DO IC = 1,NHC
               XDZ(IC) = ZERO
            END DO
            SBINV = ONE
  
C        SOLUTION BETWEEN VMID AND 1 (SOLVE FOR L WHERE LIQ = 1-V)
         ELSE
            LMIN = ZERO
            LMAX = ONE-VMID
            LIQ = HALF * (LMIN + LMAX)
C           ------------------------------------------------------------
C             ITERATION LOOP BELOW FOR TWO PHASE FOR L
C             RR = SUM( -Z(IC) / ( LIQ + B(IC) ) ), LIQ IS LIQUID FRACTION
C             D(RR)/DL >= ZERO
C           ------------------------------------------------------------  
            DO ITER = 1,ITMAX 
               RR_OLD = RR        
               XDZ_VAL(1) = -ONE/(LIQ + B(1))
               RR = Z(1)*XDZ_VAL(1)
               SBINV_VAL = RR*XDZ_VAL(1)
               DO IC = 2,NHC
                  XDZ_VAL(IC) = -ONE/(LIQ + B(IC))
                  RR = RR + Z(IC)*XDZ_VAL(IC)
                  SBINV_VAL = SBINV_VAL 
     &                      + Z(IC)*XDZ_VAL(IC)*XDZ_VAL(IC)
               END DO
               DELL = - RR/SBINV_VAL

C              MAINTAIN BOUND ON LIQ AND CHECK CONVERGENCE
               IF(RR < -TOLRR) THEN
                  LMIN = LIQ
                  IF(ABS(RR) > ABS(RR_OLD)) THEN
                     LIQ = HALF * (LMIN + LMAX)
                  ELSE
                     DELL = MIN( DELL, STEP*(LMAX-LMIN) )
                     LIQ = LIQ + DELL
                  ENDIF
               ELSEIF(RR > TOLRR) THEN
                  LMAX = LIQ
                  DELL = MAX( DELL, STEP*(LMIN-LMAX) )
                  LIQ = LIQ + DELL
               ELSE 
                  LIQ = LIQ + DELL
                  EXIT
               ENDIF
            END DO 
C           ------------------------ 
C             END OF ITERATION LOOP  
C           ------------------------ 
            DO IC = 1,NHC
               XDZ(IC) = -XDZ_VAL(IC)*A(IC)
            END DO
            V = ONE - LIQ
            SBINV = -SBINV_VAL
         ENDIF
               
C     SOLUTION BETWEEN 0 AND VMID
      ELSE
         VMIN = ZERO
         VMAX = VMID
         V = HALF * (VMIN + VMAX)
C        ------------------------------------------------------------- 
C          ITERATION LOOP BELOW FOR TWO PHASE FOR V
C          RR = SUM( Z(IC) / ( V - A(IC) ) ) WHERE V IS VAPOR FRACTION
C          D(RR)/DV =< ZERO
C        ------------------------------------------------------------- 
         DO ITER = 1,ITMAX 
            RR_OLD = RR        
            XDZ_VAL(1) = ONE/(V - A(1))
            RR = Z(1)*XDZ_VAL(1)
            SBINV_VAL = -RR*XDZ_VAL(1)
            DO IC = 2,NHC
               XDZ_VAL(IC) = ONE/(V - A(IC))
               RR = RR + Z(IC)*XDZ_VAL(IC)
               SBINV_VAL = SBINV_VAL - Z(IC)*XDZ_VAL(IC)*XDZ_VAL(IC)
            END DO
            DELV = - RR/SBINV_VAL

C           MAINTAIN BOUND ON V AND CHECK CONVERGENCE
            IF(RR > TOLRR) THEN
               VMIN = V
               IF(ABS(RR) > ABS(RR_OLD)) THEN
                  V = HALF * (VMIN + VMAX)
               ELSE
                  DELV = MIN( DELV, STEP*(VMAX-VMIN) )
                  V = V + DELV
               ENDIF
            ELSEIF(RR < -TOLRR) THEN
               VMAX = V
               DELV = MAX( DELV, STEP*(VMIN-VMAX) )
               V = V + DELV
            ELSE 
               V = V + DELV
               EXIT
            ENDIF
         END DO 
C        ------------------------ 
C          END OF ITERATION LOOP  
C        ------------------------ 
         DO IC = 1,NHC
            XDZ(IC) = -XDZ_VAL(IC)*A(IC)
         END DO
         LIQ = ONE - V
         SBINV = SBINV_VAL
      ENDIF   
      END

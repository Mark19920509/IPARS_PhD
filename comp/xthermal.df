C  XTHERMAL.F - THERMAL STEP USING ENERGY-BALANCE EQUATION. TWO OPTIONS 
C  EXPLORED: EXPLICIT- AND IMPLICIT- UPDATES (LATTER INVOLVES SOLUTION 
C  OF LINEAR SYSTEM AND IS MORE EXPENSIVE).
C  COMPOSITIONAL IMPEC MODEL

C  ROUTINES IN THIS MODULE:
C  SUBROUTINE XTHSTEP  (NERR)
C  SUBROUTINE XTHCAPACITY(IFLAG)
C  SUBROUTINE XINTEG  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,PV,PVOLD,MDEN,MDENOLD,SAT,SATOLD,
C                      RHOS,TEMPR,XCVS,XCVL,XHEAT)
C  SUBROUTINE XTHCAP  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,PV,MDEN,SAT,RHOS,XCVS,XCVL,XTCP)
C  SUBROUTINE XTSLP   (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,MDEN,MDENOLD,TEMPR,XCPL,XSLP)
C  SUBROUTINE XTADVX  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,MDEN,MDENOLD,XVEL,XVELOLD,
C                      TEMPR,XCPL,XHEAT)
C  SUBROUTINE XTADVY  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,MDEN,MDENOLD,XVEL,XVELOLD,
C                      TEMPR,XCPL,XHEAT)
C  SUBROUTINE XTADVZ  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,MDEN,MDENOLD,XVEL,XVELOLD,
C                      TEMPR,XCPL,XHEAT)
C  SUBROUTINE XTDFFA  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,PV,MDEN,MDENOLD,SAT,SATOLD,RHOS,
C                      TEMPR,XCVS,XCVL,XHEAT,XTCOF,XTRESID,XTDUNK)
C  SUBROUTINE XTDFFBD (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TEMPR,XTCOND,XTCOF,XTRESID,XHEAT)
C  SUBROUTINE XTUPDBD (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TEMPR,XTCOND,XHEAT)
C  SUBROUTINE XTDFFX  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,TEMPR,XTCOND,XTCOF,XTRESID,
C                      XHEAT)
C  SUBROUTINE XTDFFY  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,TEMPR,XTCOND,XTCOF,XTRESID,
C                      XHEAT)
C  SUBROUTINE XTDFFZ  (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TCOF,TEMPR,XTCOND,XTCOF,XTRESID,
C                      XHEAT)
C  SUBROUTINE XUPTMPR (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,PV,PVOLD,MDEN,MDENOLD,SAT,SATOLD,
C                      RHOS,TEMPR,XCVS,XCVL,XHEAT)
C  SUBROUTINE XGETDTEMPRBD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                          KL2,KEYOUT,NBLK,TEMPR,XTDUNK)
C  SUBROUTINE XSETTMPR(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,TEMPR,XTDUNK)
C  SUBROUTINE XTMPWELL(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,MOLFRAC,TEMPR,XCPL,XHEAT)
C  SUBROUTINE XTHCOND (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,PV,PVOLD,SAT,SATOLD,TEMPR,XTCOND)
C  SUBROUTINE XTHCONDBD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                      KL2,KEYOUT,NBLK,PV,PVOLD,SAT,SATOLD,XTCOND)
C  SUBROUTINE XSPHEAT (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                      KEYOUT,NBLK,MOLFRAC,XCPL,XCVL,XCVS)
C  SUBROUTINE XTLINSOL(ITLN,NERR)
C  REAL*8 FUNCTION SGNT(A,B)
C  REAL*8 FUNCTION HRMNCMEAN(A,B)
C  NOTE: 1 BTU=3.362D-6 FT-LB/SQ-DAY. CONVERSION ALREADY DONE INSIDE
C        SUBROUTINES IN XTHCOND AND XSPHEAT BEFORE BEING USED IN THE 
C        OTHER SUBROUTINES. BUT FOR ILLUSTRATION UNITS ARE MENTIONED 
C        AS BTU/LB-F AND BTU/FT-DAY-F IN COMMENTS.
C  CODE HISTORY:

C  SUNIL G. THOMAS  12/27/07   ALPHA VERSION (REF: M. DELSHAD NOTES, 
C                              K. M. BRANTFERGER, UTCHEM 5.2)
C  SUNIL G. THOMAS  03/01/08   CORRECTIONS FOR PARALLEL, WELLS, CFL
C  SUNIL G. THOMAS  05/28/08   HIGHER-ORDER GODUNOV METHOD WITH SLOPE-
C                              LIMITER FOR MORE ACCURATE HEAT FLUX 
C                              RECONSTRUCTION
C  SUNIL G. THOMAS  07/01/09   HEAT LOSS IMPLEMENTATION (BASED ON WORK 
C                              OF VINSOME-VESTERWELD)
C***********************************************************************

C***********************************************************************
      SUBROUTINE XTHSTEP(NERR)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'blkary.h'
      INCLUDE 'xarydat.h'
      INCLUDE 'xthermal.h'

      INTEGER  JINTEG(12),JTMPWELL(7),JTSLP(6),JTADV(11),JTDFFA(15),
     &         JTDFF(7),JTDFFBD(6),JTUPDBD(5),JUPTMPR(12),JGETDTMP(3),
     &         JSETTMPR(3),JPNT(3),JTHCOND(7),JSPHEAT(7)
      SAVE     JINTEG,JTMPWELL,JTSLP,JTADV,JTDFFA,JTDFF,JTDFFBD,JTUPDBD,
     &         JUPTMPR,JGETDTMP,JSETTMPR,JPNT,JTHCOND,JSPHEAT
      EXTERNAL XINTEG,XTMPWELL,XTSLP,XTADVX,XTADVY,XTADVZ,XTDFFA,XTDFFX,
     &         XTDFFY,XTDFFZ,XTDFFBD,XTUPDBD,XUPTMPR,XGETDTEMPRBD,
     &         XSETTMPR,XTHCOND,XSPHEAT,TASSIGN
      LOGICAL ONCEONLY
      INTEGER ITTLN,NTERR,NERR
      DATA ONCEONLY /.TRUE./,ITTLN /0/,NTERR /0/

C  DEFINE WORK ROUTINE ARGUMENTS 

      IF (ONCEONLY) THEN
         ONCEONLY=.FALSE.

         JINTEG(1)=11
         JINTEG(2)=N_XRHOS
         JINTEG(3)=N_XCVS
         JINTEG(4)=N_XCVL
         JINTEG(5)=N_PV
         JINTEG(6)=N_PVN
         JINTEG(7)=N_PMDEN
         JINTEG(8)=N_PMDENN
         JINTEG(9)=N_SAT
         JINTEG(10)=N_SATN
         JINTEG(11)=N_TEMPR
         JINTEG(12)=N_XHEAT

         JTMPWELL(1)=6
         JTMPWELL(2)=N_KSI
         JTMPWELL(3)=N_KSIN
         JTMPWELL(4)=N_TEMPR
         JTMPWELL(5)=N_XCPL
         JTMPWELL(6)=N_XHEAT
         JTMPWELL(7)=N_XTCP

         JTSLP(1)=5
         JTSLP(2)=N_PMDEN
         JTSLP(3)=N_PMDENN
         JTSLP(4)=N_TEMPR
         JTSLP(5)=N_XCPL
         JTSLP(6)=N_XSLP

         JTADV(1)=10
         JTADV(3)=N_PMDEN
         JTADV(4)=N_PMDENN
         JTADV(5)=N_XVEL
         JTADV(6)=N_XVELN
         JTADV(7)=N_TEMPR
         JTADV(8)=N_XCPL
         JTADV(9)=N_XHEAT
         JTADV(10)=N_XTCPN
         JTADV(11)=N_XSLP

         JTDFFA(1)=14
         JTDFFA(2)=N_XRHOS
         JTDFFA(3)=N_XCVS
         JTDFFA(4)=N_XCVL
         JTDFFA(5)=N_PV
         JTDFFA(6)=N_PVN
         JTDFFA(7)=N_PMDEN
         JTDFFA(8)=N_PMDENN
         JTDFFA(9)=N_SAT
         JTDFFA(10)=N_SATN
         JTDFFA(11)=N_TEMPR
         JTDFFA(12)=N_XHEAT
         JTDFFA(13)=N_XTCOF
         JTDFFA(14)=N_XTRESID
         JTDFFA(15)=N_XTDUNK

         JTDFFBD(1)=5
         JTDFFBD(2)=N_TEMPR
         JTDFFBD(3)=N_XTCOND
         JTDFFBD(4)=N_XTCOF
         JTDFFBD(5)=N_XTRESID
         JTDFFBD(6)=N_XHEAT

         JTUPDBD(1)=4
         JTUPDBD(2)=N_TEMPR
         JTUPDBD(3)=N_XTCOND
         JTUPDBD(4)=N_XTRESID
         JTUPDBD(5)=N_XHEAT

         JTDFF(1)=6
         JTDFF(3)=N_TEMPR
         JTDFF(4)=N_XTCOND
         JTDFF(5)=N_XTCOF
         JTDFF(6)=N_XTRESID
         JTDFF(7)=N_XHEAT

         JUPTMPR(1)=11
         JUPTMPR(2)=N_XRHOS
         JUPTMPR(3)=N_XCVS
         JUPTMPR(4)=N_XCVL
         JUPTMPR(5)=N_PV
         JUPTMPR(6)=N_PVN
         JUPTMPR(7)=N_PMDEN
         JUPTMPR(8)=N_PMDENN
         JUPTMPR(9)=N_SAT
         JUPTMPR(10)=N_SATN
         JUPTMPR(11)=N_TEMPR
         JUPTMPR(12)=N_XHEAT

         JGETDTMP(1)=2
         JGETDTMP(2)=N_TEMPR
         JGETDTMP(3)=N_XTDUNK

         JSETTMPR(1)=2
         JSETTMPR(2)=N_TEMPR
         JSETTMPR(3)=N_XTDUNK

         JPNT(1)=2
         JPNT(2)=N_TEMPR
         JPNT(3)=N_CTAB

         JTHCOND(1)=6
         JTHCOND(2)=N_PV
c--------note inside XSTEP3, from where XTHSTEP is called, N_XRESID 
c        stores old pore volume.
         JTHCOND(3)=N_XRESID
         JTHCOND(4)=N_SAT
         JTHCOND(5)=N_SATN
         JTHCOND(6)=N_TEMPR
         JTHCOND(7)=N_XTCOND

         JSPHEAT(1)=6
         JSPHEAT(2)=N_TEMPR
         JSPHEAT(3)=N_KSI
         JSPHEAT(4)=N_KSIN
         JSPHEAT(5)=N_XCPL
         JSPHEAT(6)=N_XCVL
         JSPHEAT(7)=N_XCVS

      ENDIF

C-------update thermal energy of reservoir
         THTFAC=(THTIM-TIM)/DELTIM
         CALL CALLWORK(XSPHEAT,JSPHEAT)

         THTFAC=(THTIM-TIM)/DELTIM
         CALL CALLWORK(XINTEG,JINTEG)

C-------heat source/sink terms
         THCFLSTEP=THDTIM
         XTHCFLERR=.FALSE.
         THTFAC=(THTIM-TIM)/DELTIM
         CALL CALLWORK(XTMPWELL,JTMPWELL)

         IF(XTHCFLERR .AND. (THCFLSTEP < THDTIM)) THEN
            IF(LEVELC) THEN
               WRITE(NFOUT,*) 'ERROR: THERMAL CFL VIOLATED AT WELLS'
               WRITE(NFOUT,*) 'THSTEP=',THDTIM,' CFL=',THCFLSTEP,
     &                        ' AT FLOW STEP ',NSTEP,' TIMES:< ',
     &                         THTIM,',',THTIM_NEW,'>'
               WRITE(0,*) 'ERROR: THERMAL CFL VIOLATED AT WELLS'
               WRITE(0,*) 'THSTEP=',THDTIM,' CFL=',THCFLSTEP,
     &                    ' AT FLOW STEP ',NSTEP,' TIMES:< ',
     &                      THTIM,',',THTIM_NEW,'>' 
            ENDIF
            NERR=NERR+1
            RETURN
         ENDIF

         THTFAC=(THTIM_HALF-TIM)/DELTIM
         CALL CALLWORK(XSPHEAT,JSPHEAT)
C-------temperature advection term
         THTFAC=(THTIM_HALF-TIM)/DELTIM
         THCFLSTEP=THDTIM
         XTHCFLERR=.FALSE.
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_XHEAT,1)
$MANY         CALL UPDATE(N_TEMPR,1)
$MANY         CALL UPDATE(N_XCPL,1)
$MANY         CALL UPDATE(N_XVEL,1)
$MANY         CALL TIMOFF(3)
         IF(.NOT.XNOFLXLMTR) CALL CALLWORK(XTSLP,JTSLP)
         JTADV(2)=N_TCOFX
         CALL CALLWORK(XTADVX,JTADV)
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_XHEAT,1)
$MANY         CALL TIMOFF(3)
         JTADV(2)=N_TCOFY
         CALL CALLWORK(XTADVY,JTADV)
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_XHEAT,1)
$MANY         CALL TIMOFF(3)
         JTADV(2)=N_TCOFZ
         CALL CALLWORK(XTADVZ,JTADV)
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_XHEAT,1)
$MANY         CALL UPDATE(N_XTCOND,1)
$MANY         CALL TIMOFF(3)

         IF(XTHCFLERR .AND. (THCFLSTEP < THDTIM)) THEN
            IF(LEVELC) THEN
               WRITE(NFOUT,*) 'ERROR: THERMAL CFL VIOLATED IN ADVECTION'
               WRITE(NFOUT,*) 'THSTEP=',THDTIM,' CFL=',THCFLSTEP,
     &                        ' AT FLOW STEP ',NSTEP,' TIMES:< ',
     &                         THTIM,',',THTIM_NEW,'>'
               WRITE(0,*) 'ERROR: THERMAL CFL VIOLATED IN ADVECTION'
               WRITE(0,*) 'THSTEP=',THDTIM,' CFL=',THCFLSTEP,
     &                    ' AT FLOW STEP ',NSTEP,' TIMES:< ',
     &                      THTIM,',',THTIM_NEW,'>'
            ENDIF
            NERR=NERR+1
            RETURN
         ENDIF

C-------update temperature after advection
         THTFAC=(THTIM_NEW-TIM)/DELTIM
CSGT         THTFAC=(THTIM_HALF-TIM)/DELTIM
CSGT         THTFAC=(THTIM-TIM)/DELTIM
         CALL CALLWORK(XSPHEAT,JSPHEAT)
         CALL CALLWORK(XUPTMPR,JUPTMPR)
         THTFAC=(THTIM_NEW-TIM)/DELTIM

C-------temperature diffusion term
         IF(XNOTHCOND) GOTO 13
         IF(XTHSOLVE) CALL CALLWORK(XTDFFA,JTDFFA)
         IF(XHEATLOSS) CALL CALLWORK(XTDFFBD,JTDFFBD)
         JTDFF(2)=N_TCOFX
         CALL CALLWORK(XTDFFX,JTDFF)
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_XHEAT,1)
$MANY         CALL TIMOFF(3)
         JTDFF(2)=N_TCOFY
         CALL CALLWORK(XTDFFY,JTDFF)
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_XHEAT,1)
$MANY         CALL TIMOFF(3)
         JTDFF(2)=N_TCOFZ
         CALL CALLWORK(XTDFFZ,JTDFF)
$MANY         CALL TIMON(3)
$MANY         CALL UPDATE(N_XHEAT,1)
$MANY         CALL TIMOFF(3)
         IF(XTHSOLVE) THEN
            CALL XTLINSOL(ITTLN,NTERR)
            IF(XHEATLOSS) CALL CALLWORK(XGETDTEMPRBD,JGETDTMP)
            CALL CALLWORK(XSETTMPR,JSETTMPR)
         ELSE
            CALL CALLWORK(XUPTMPR,JUPTMPR)
         ENDIF
   13    CONTINUE
         CALL CALLWORK(TASSIGN,JPNT)
         NRESVTEMP=NTEMP
         IF(.NOT.XNOTHCOND) CALL CALLWORK(XTHCOND,JTHCOND)
         IF(XHEATLOSS) CALL CALLWORK(XTUPDBD,JTUPDBD)

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTHCAPACITY(IFLAG)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xarydat.h'

      INTEGER IFLAG,ITHCAP(8),IOLD,INEW
      LOGICAL ONCEONLY
      EXTERNAL XTHCAP
      DATA ONCEONLY/.TRUE./,ITHCAP/8*0/
      PARAMETER (IOLD=0,INEW=1)

      IF(ONCEONLY) THEN
         ONCEONLY = .FALSE.
         ITHCAP(1)=7
         ITHCAP(5)=N_XRHOS
         ITHCAP(6)=N_XCVS
         ITHCAP(7)=N_XCVL
      ENDIF

      IF(IFLAG == IOLD) THEN
c--------note inside XSTEP3, from where XTHSTEP is called, N_XRESID 
c        stores old pore volume.
         ITHCAP(2)=N_XRESID
         ITHCAP(3)=N_PMDENN
         ITHCAP(4)=N_SATN
         ITHCAP(8)=N_XTCPN
      ELSEIF(IFLAG == INEW) THEN
         ITHCAP(2)=N_PV
         ITHCAP(3)=N_PMDEN
         ITHCAP(4)=N_SAT
         ITHCAP(8)=N_XTCP
      ELSE
         STOP 'ERROR IN XTHCAPACITY, UNSUPPORTED FLAG!!'
      ENDIF

      CALL CALLWORK(XTHCAP,ITHCAP)

      RETURN
      END


C***********************************************************************
      SUBROUTINE XTHCAP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,PV,MDEN,SAT,RHOS,XCVS,XCVL,XTCP)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C***********************************************************************
C  THIS ROUTINE EVALUATES 'RESERVOIR THERMAL CAPACITY', XTCP
C  INPUT:
C      PV =      PORE VOLUME (CU-FT, REAL*8)
C      MDEN =    PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      SAT =     PHASE SATURATIONS (REAL*8)
C      RHOS =    RESERVOIR ROCK MASS DENSITY (LB/CU-FT, REAL*8)
C      XCVS =    RESERVOIR ROCK CONSTANT VOLUME SPECIFIC HEAT 
C                CAPACITY (BTU/LB-F, REAL*8)
C      XCVL =    PHASE CONSTANT VOLUME SPECIFIC HEAT CAPACITY 
C                (BTU/LB-F, REAL*8)
C  OUTPUT:
C      XTCP =    RESERVOIR THERMAL CAPACITY (BTU/F, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  PV(IDIM,JDIM,KDIM),MDEN(IDIM,JDIM,KDIM,NPH),
     &        SAT(IDIM,JDIM,KDIM,NPH),RHOS(IDIM,JDIM,KDIM),
     &        XCVS(IDIM,JDIM,KDIM),XCVL(IDIM,JDIM,KDIM,NPH),
     &        XTCP(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,K,IOFF,JOFF,KOFF,IERR,IPH
      REAL*8 DX,DY,DZ,VOL
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTHCAP: READING BLKOFF!'
         STOP 13
      ENDIF

C  COMPUTE THERMAL CAPACITY XTCP
      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               XTCP(I,J,K) = ZERO
               IF(KEYOUT(I,J,K) <= 0) CYCLE
               DX=DXREC(I+IOFF,NBLK)
               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               VOL=DX*DY*DZ
               XTCP(I,J,K)=XTCP(I,J,K)+(VOL-PV(I,J,K))*RHOS(I,J,K)
     &                    *XCVS(I,J,K)
               DO IPH=1,NPH
                  XTCP(I,J,K)=XTCP(I,J,K)+PV(I,J,K)*MDEN(I,J,K,IPH)
     &                       *SAT(I,J,K,IPH)*XCVL(I,J,K,IPH)
               END DO
            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XINTEG(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &               KEYOUT,NBLK,RHOS,XCVS,XCVL,PV,PVOLD,MDEN,MDENOLD,
     &               SAT,SATOLD,TEMPR,XHEAT)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE EVALUATES 'INTERNAL HEAT ENERGY CONTENT', XHEAT
C  INPUT:
C      TEMPR =     RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      PV(OLD) =   (OLD TIME) PORE VOLUME (CU-FT, REAL*8)
C      MDEN(OLD) = (OLD TIME) PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      SAT(OLD) =  (OLD TIME) PHASE SATURATIONS (REAL*8)
C      RHOS =      RESERVOIR ROCK MASS DENSITY (LB/CU-FT, REAL*8)
C      XCVS =      RESERVOIR ROCK CONSTANT VOLUME SPECIFIC HEAT 
C                  CAPACITY (BTU/LB-F, REAL*8)
C      XCVL =      PHASE CONSTANT VOLUME SPECIFIC HEAT CAPACITY 
C                  (BTU/LB-F, REAL*8)
C  OUTPUT:
C      XHEAT =     LOCAL INTERNAL HEAT ENERGY CONTENT
C                  (FT-LB/SQ-DAY, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  TEMPR(IDIM,JDIM,KDIM),XHEAT(IDIM,JDIM,KDIM),
     &        RHOS(IDIM,JDIM,KDIM),XCVS(IDIM,JDIM,KDIM),
     &        XCVL(IDIM,JDIM,KDIM,NPH),PV(IDIM,JDIM,KDIM),
     &        PVOLD(IDIM,JDIM,KDIM),MDEN(IDIM,JDIM,KDIM,NPH),
     &        MDENOLD(IDIM,JDIM,KDIM,NPH),SAT(IDIM,JDIM,KDIM,NPH),
     &        SATOLD(IDIM,JDIM,KDIM,NPH)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,K,IOFF,JOFF,KOFF,IERR,IPH
      REAL*8 DX,DY,DZ,VOL,XTCPC,PVI,SATI,MDENI
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XINTEG: READING BLKOFF!'
         STOP 13
      ENDIF

C  COMPUTE XHEAT
      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               XHEAT(I,J,K) = ZERO
               XTCPC = ZERO
               IF(KEYOUT(I,J,K) <= 0) CYCLE
               DX=DXREC(I+IOFF,NBLK)
               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               VOL=DX*DY*DZ
               PVI=PVOLD(I,J,K)+THTFAC*(PV(I,J,K)-PVOLD(I,J,K))
               XTCPC=XTCPC+(VOL-PVI)*RHOS(I,J,K)*XCVS(I,J,K)
               DO IPH=1,NPH
                  SATI=SATOLD(I,J,K,IPH)+THTFAC*(SAT(I,J,K,IPH)
     &                                          -SATOLD(I,J,K,IPH))
                  MDENI=MDENOLD(I,J,K,IPH)+THTFAC*(MDEN(I,J,K,IPH)
     &                                            -MDENOLD(I,J,K,IPH))
                  XTCPC=XTCPC+PVI*MDENI*SATI*XCVL(I,J,K,IPH)
               END DO
               XHEAT(I,J,K)=XTCPC*TEMPR(I,J,K)
            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTSLP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK,MDEN,MDENOLD,TEMPR,XCPL,XSLP)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE EVALUATES SCALAR VARIABLE SLOPE INFO FOR EACH PHASE. 
C  INTENDED FOR THE THERMAL FLUX RECONSTRUCTION BUT CAN POTENTIALLY 
C  BE USED WITH OTHER ADVECTION PHYSICS SUCH AS IN SPECIES TRANSPORT.
C  INPUT:
C      MDEN =    PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      MDENOLD = OLD TIME PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XCPL =    FLUID PHASE ISOBARIC SPECIFIC HEAT CAPACITY OR
C                'SPECIFIC ENTHALPY' (BTU/LB-F, REAL*8) 
C  OUTPUT:
C      XSLP =    SLOPES OF THERMAL ENTHALPY (BTU/QA-FT, REAL*8)
C  PARAMETER:
C      NFLXLMT = TYPE OF FLUX LIMITER, (INTEGER, DEFAULT 0)
C               (0. CENTERED DIFFERENCES, 1. MIN-MOD, 2. VAN-LEER 
C                   HARMONIC MEAN, 3. 'SUPER-BEE')
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  MDEN(IDIM,JDIM,KDIM,NPH),MDENOLD(IDIM,JDIM,KDIM,NPH),
     &        TEMPR(IDIM,JDIM,KDIM),XCPL(IDIM,JDIM,KDIM,NPH),
     &        XSLP(IDIM,JDIM,KDIM,NPH,3)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,K,IM1,IP1,JM1,JP1,KM1,KP1,IOFF,JOFF,KOFF,IERR,IPH
      REAL*8 DX,DY,DZ,DXC,DXM,DXP,DYC,DYM,DYP,DZC,DZM,DZP,CP,CPM,CPP,
     &       TMP,TMPM,TMPP,PHD,PHDM,PHDP,RCPT,RCPTM,RCPTP,DRCPTMDX,
     &       DRCPTPDX,DRCPTMDY,DRCPTPDY,DRCPTMDZ,DRCPTPDZ,SIGNT,ARG1,
     &       ARG2
      REAL*8 HRMNCMEAN,SGNT
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTSLP: READING BLKOFF!'
         STOP 13
      ENDIF

      DO IPH = 1,NPH     

C----------get element slopes

         DO K = KL1,KL2
            DO J=JL1V(K),JL2V(K)
               DO I=IL1,IL2
                  IF(KEYOUT(I,J,K) <= 0) CYCLE
                  IM1 = I-1
                  IP1 = I+1
                  JM1 = J-1
                  JP1 = J+1
                  KM1 = K-1
                  KP1 = K+1
                  DX = DXREC(I+IOFF,NBLK)
                  DY = DYREC(J+JOFF,NBLK)
                  DZ = DZREC(K+KOFF,NBLK)

                  PHD = MDENOLD(I,J,K,IPH)+THTFAC
     &                *(MDEN(I,J,K,IPH)-MDENOLD(I,J,K,IPH))
                  CP = XCPL(I,J,K,IPH)
                  TMP = TEMPR(I,J,K)
                  RCPT = PHD*CP*TMP

C----------x-direction slopes
                  IF(KEYOUT(IP1,J,K)/=0 .AND. KEYOUT(IM1,J,K)==0) THEN
                     DXM = DX
                     DXP = DXREC(IP1+IOFF,NBLK)
                     DXC = HALF*(DX+DXP)
                     TMPM = TMP
                     TMPP = TEMPR(IP1,J,K)
                     CPM = CP
                     CPP = XCPL(IP1,J,K,IPH)
                     PHDM = PHD
                     PHDP = MDENOLD(IP1,J,K,IPH)+THTFAC
     &                    *(MDEN(IP1,J,K,IPH)-MDENOLD(IP1,J,K,IPH))
                  ELSEIF(KEYOUT(IM1,J,K)/=0 .AND. KEYOUT(IP1,J,K)==0) 
     &            THEN
                     DXP = DX
                     DXM = DXREC(IM1+IOFF,NBLK)
                     DXC = HALF*(DX+DXM)
                     TMPM = TEMPR(IM1,J,K)
                     TMPP = TMP
                     CPM = XCPL(IM1,J,K,IPH)
                     CPP = CP
                     PHDM = MDENOLD(IM1,J,K,IPH)+THTFAC
     &                    *(MDEN(IM1,J,K,IPH)-MDENOLD(IM1,J,K,IPH))
                     PHDP = PHD
                  ELSEIF(KEYOUT(IM1,J,K)==0 .AND. KEYOUT(IP1,J,K)==0)
     &            THEN
                     DXP = DX
                     DXM = DX
                     DXC = DX
                     TMPM = TMP
                     TMPP = TMP
                     CPM = CP
                     CPP = CP
                     PHDM = PHD
                     PHDP = PHD
                  ELSE
                     DXM = DXREC(IM1+IOFF,NBLK)
                     DXP = DXREC(IP1+IOFF,NBLK)
                     DXC = DX+HALF*(DXM+DXP)
                     TMPM = TEMPR(IM1,J,K)
                     TMPP = TEMPR(IP1,J,K)
                     CPM = XCPL(IM1,J,K,IPH)
                     CPP = XCPL(IP1,J,K,IPH)
                     PHDM = MDENOLD(IM1,J,K,IPH)+THTFAC
     &                    *(MDEN(IM1,J,K,IPH)-MDENOLD(IM1,J,K,IPH))
                     PHDP = MDENOLD(IP1,J,K,IPH)+THTFAC
     &                    *(MDEN(IP1,J,K,IPH)-MDENOLD(IP1,J,K,IPH))
                  ENDIF
                  RCPTM = PHDM*CPM*TMPM
                  RCPTP = PHDP*CPP*TMPP

                  IF(NFLXLMT == 0) THEN
                     XSLP(I,J,K,IPH,1) = (RCPTP-RCPTM)/DXC
                  ELSEIF(NFLXLMT == 1) THEN
                     DRCPTMDX = (RCPT-RCPTM)/(HALF*(DXM+DX))
                     DRCPTPDX = (RCPTP-RCPT)/(HALF*(DXP+DX))
                     XSLP(I,J,K,IPH,1) = 
     &                  MIN(MAX(DRCPTMDX,ZERO),MAX(DRCPTPDX,ZERO))
     &                 +MAX(MIN(DRCPTMDX,ZERO),MIN(DRCPTPDX,ZERO))
                  ELSEIF(NFLXLMT == 2) THEN
                     DRCPTMDX = (RCPT-RCPTM)/(HALF*(DXM+DX))
                     DRCPTPDX = (RCPTP-RCPT)/(HALF*(DXP+DX))
                     XSLP(I,J,K,IPH,1) = HRMNCMEAN(DRCPTMDX,DRCPTPDX)
                  ELSEIF(NFLXLMT == 3) THEN
                     DRCPTMDX = (RCPT-RCPTM)/(HALF*(DXM+DX))
                     DRCPTPDX = (RCPTP-RCPT)/(HALF*(DXP+DX))
                     SIGNT = SGNT(DRCPTMDX,DRCPTPDX)
                     ARG1 = MIN(ABS(DRCPTMDX),ABS(DRCPTPDX))
                     ARG2 = HALF*MAX(ABS(DRCPTMDX),ABS(DRCPTPDX))
                     XSLP(I,J,K,IPH,1) = SIGNT*MIN(ARG1,ARG2)
                  ELSE
                     WRITE(0,*) 'WARNING: FLUX LIMITER TYPE UNDEFINED ',
     &                          'DEFAULTS TO 0 (CENTERED DIFFERENCES)'
                     XSLP(I,J,K,IPH,1) = (RCPTP-RCPTM)/DXC
                  ENDIF

C----------y-direction slopes
                  IF(KEYOUT(I,JP1,K)/=0 .AND. KEYOUT(I,JM1,K)==0) THEN
                     DYM = DY
                     DYP = DYREC(JP1+JOFF,NBLK)
                     DYC = HALF*(DY+DYP)
                     TMPM = TMP
                     TMPP = TEMPR(I,JP1,K)
                     CPM = CP
                     CPP = XCPL(I,JP1,K,IPH)
                     PHDM = PHD
                     PHDP = MDENOLD(I,JP1,K,IPH)+THTFAC
     &                    *(MDEN(I,JP1,K,IPH)-MDENOLD(I,JP1,K,IPH))
                  ELSEIF(KEYOUT(I,JM1,K)/=0 .AND. KEYOUT(I,JP1,K)==0)
     &            THEN
                     DYM = DYREC(JM1+JOFF,NBLK)
                     DYP = DY
                     DYC = HALF*(DY+DYM)
                     TMPM = TEMPR(I,JM1,K)
                     TMPP = TMP
                     CPM = XCPL(I,JM1,K,IPH)
                     CPP = CP
                     PHDM = MDENOLD(I,JM1,K,IPH)+THTFAC
     &                    *(MDEN(I,JM1,K,IPH)-MDENOLD(I,JM1,K,IPH))
                     PHDP = PHD
                  ELSEIF(KEYOUT(I,JM1,K)==0 .AND. KEYOUT(I,JP1,K)==0)
     &            THEN
                     DYM = DY
                     DYP = DY
                     DYC = DY
                     TMPM = TMP
                     TMPP = TMP
                     CPM = CP
                     CPP = CP
                     PHDM = PHD
                     PHDP = PHD
                  ELSE
                     DYM = DYREC(JM1+JOFF,NBLK)
                     DYP = DYREC(JP1+JOFF,NBLK)
                     DYC = DY+HALF*(DYM+DYP)
                     TMPM = TEMPR(I,JM1,K)
                     TMPP = TEMPR(I,JP1,K)
                     CPM = XCPL(I,JM1,K,IPH)
                     CPP = XCPL(I,JP1,K,IPH)
                     PHDM = MDENOLD(I,JM1,K,IPH)+THTFAC
     &                    *(MDEN(I,JM1,K,IPH)-MDENOLD(I,JM1,K,IPH))
                     PHDP = MDENOLD(I,JP1,K,IPH)+THTFAC
     &                    *(MDEN(I,JP1,K,IPH)-MDENOLD(I,JP1,K,IPH))
                  ENDIF
                  RCPTM = PHDM*CPM*TMPM
                  RCPTP = PHDP*CPP*TMPP

                  IF(NFLXLMT == 0) THEN
                     XSLP(I,J,K,IPH,2) = (RCPTP-RCPTM)/DYC
                  ELSEIF(NFLXLMT == 1) THEN
                     DRCPTMDY = (RCPT-RCPTM)/(HALF*(DYM+DY))
                     DRCPTPDY = (RCPTP-RCPT)/(HALF*(DYP+DY))
                     XSLP(I,J,K,IPH,2) = 
     &                  MIN(MAX(DRCPTMDY,ZERO),MAX(DRCPTPDY,ZERO))
     &                 +MAX(MIN(DRCPTMDY,ZERO),MIN(DRCPTPDY,ZERO))
                  ELSEIF(NFLXLMT == 2) THEN
                     DRCPTMDY = (RCPT-RCPTM)/(HALF*(DYM+DY))
                     DRCPTPDY = (RCPTP-RCPT)/(HALF*(DYP+DY))
                     XSLP(I,J,K,IPH,2) = HRMNCMEAN(DRCPTMDY,DRCPTPDY)
                  ELSEIF(NFLXLMT == 3) THEN
                     DRCPTMDY = (RCPT-RCPTM)/(HALF*(DYM+DY))
                     DRCPTPDY = (RCPTP-RCPT)/(HALF*(DYP+DY))
                     SIGNT = SGNT(DRCPTMDY,DRCPTPDY)
                     ARG1 = MIN(ABS(DRCPTMDY),ABS(DRCPTPDY))
                     ARG2 = HALF*MAX(ABS(DRCPTMDY),ABS(DRCPTPDY))
                     XSLP(I,J,K,IPH,2) = SIGNT*MIN(ARG1,ARG2)
                  ELSE
                     WRITE(0,*) 'WARNING: FLUX LIMITER TYPE UNDEFINED ',
     &                          'DEFAULTS TO 0 (CENTERED DIFFERENCES)'
                     XSLP(I,J,K,IPH,2) = (RCPTP-RCPTM)/DYC
                  ENDIF

C----------z-direction slopes
                  IF(KEYOUT(I,J,KP1)/=0 .AND. KEYOUT(I,J,KM1)==0) THEN
                     DZM = DZ
                     DZP = DZREC(KP1+KOFF,NBLK)
                     DZC = HALF*(DZ+DZP)
                     TMPM = TMP
                     TMPP = TEMPR(I,J,KP1)
                     CPM = CP
                     CPP = XCPL(I,J,KP1,IPH)
                     PHDM = PHD
                     PHDP = MDENOLD(I,J,KP1,IPH)+THTFAC
     &                    *(MDEN(I,J,KP1,IPH)-MDENOLD(I,J,KP1,IPH))
                  ELSEIF(KEYOUT(I,J,KM1)/=0 .AND. KEYOUT(I,J,KP1)==0) 
     &            THEN
                     DZM = DZREC(KM1+KOFF,NBLK)
                     DZP = DZ
                     DZC = HALF*(DZ+DZM)
                     TMPM = TEMPR(I,J,KM1)
                     TMPP = TMP
                     CPM = XCPL(I,J,KM1,IPH)
                     CPP = CP
                     PHDM = MDENOLD(I,J,KM1,IPH)+THTFAC
     &                    *(MDEN(I,J,KM1,IPH)-MDENOLD(I,J,KM1,IPH))
                     PHDP = PHD
                  ELSEIF(KEYOUT(I,J,KM1)==0 .AND. KEYOUT(I,J,KP1)==0)
     &            THEN
                     DZM = DZ
                     DZP = DZ
                     DZC = DZ
                     TMPM = TMP
                     TMPP = TMP
                     CPM = CP
                     CPP = CP
                     PHDM = PHD
                     PHDP = PHD
                  ELSE
                     DZM = DZREC(KM1+KOFF,NBLK)
                     DZP = DZREC(KP1+KOFF,NBLK)
                     DZC = DZ+HALF*(DZM+DZP)
                     TMPM = TEMPR(I,J,KM1)
                     TMPP = TEMPR(I,J,KP1)
                     CPM = XCPL(I,J,KM1,IPH)
                     CPP = XCPL(I,J,KP1,IPH)
                     PHDM = MDENOLD(I,J,KM1,IPH)+THTFAC
     &                    *(MDEN(I,J,KM1,IPH)-MDENOLD(I,J,KM1,IPH))
                     PHDP = MDENOLD(I,J,KP1,IPH)+THTFAC
     &                    *(MDEN(I,J,KP1,IPH)-MDENOLD(I,J,KP1,IPH))
                  ENDIF
                  RCPTM = PHDM*CPM*TMPM
                  RCPTP = PHDP*CPP*TMPP

                  IF(NFLXLMT == 0) THEN
                     XSLP(I,J,K,IPH,3) = (RCPTP-RCPTM)/DZC
                  ELSEIF(NFLXLMT == 1) THEN
                     DRCPTMDZ = (RCPT-RCPTM)/(HALF*(DZM+DZ))
                     DRCPTPDZ = (RCPTP-RCPT)/(HALF*(DZP+DZ))
                     XSLP(I,J,K,IPH,3) = 
     &                  MIN(MAX(DRCPTMDZ,ZERO),MAX(DRCPTPDZ,ZERO))
     &                 +MAX(MIN(DRCPTMDZ,ZERO),MIN(DRCPTPDZ,ZERO))
                  ELSEIF(NFLXLMT == 2) THEN
                     DRCPTMDZ = (RCPT-RCPTM)/(HALF*(DZM+DZ))
                     DRCPTPDZ = (RCPTP-RCPT)/(HALF*(DZP+DZ))
                     XSLP(I,J,K,IPH,3) = HRMNCMEAN(DRCPTMDZ,DRCPTPDZ)
                  ELSEIF(NFLXLMT == 3) THEN
                     DRCPTMDZ = (RCPT-RCPTM)/(HALF*(DZM+DZ))
                     DRCPTPDZ = (RCPTP-RCPT)/(HALF*(DZP+DZ))
                     SIGNT = SGNT(DRCPTMDZ,DRCPTPDZ)
                     ARG1 = MIN(ABS(DRCPTMDZ),ABS(DRCPTPDZ))
                     ARG2 = HALF*MAX(ABS(DRCPTMDZ),ABS(DRCPTPDZ))
                     XSLP(I,J,K,IPH,3) = SIGNT*MIN(ARG1,ARG2)
                  ELSE
                     WRITE(0,*) 'WARNING: FLUX LIMITER TYPE UNDEFINED ',
     &                          'DEFAULTS TO 0 (CENTERED DIFFERENCES)'
                     XSLP(I,J,K,IPH,3) = (RCPTP-RCPTM)/DZC
                  ENDIF

               END DO
            END DO
         END DO

      END DO

      RETURN
      END


C***********************************************************************
      SUBROUTINE XTADVX(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,MDEN,MDENOLD,XVEL,XVELOLD,
     &                  TEMPR,XCPL,XHEAT,XTCP,XSLP)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE EVALUATES X-TRANSPORT OF HEAT BY ADVECTION, UPDATES XHEAT. 
C  INPUT:
C      TCOF =    X-TRANSMISSIBILITY (CU-FT-CP/PSI-DAY, REAL*8)
C      MDEN =    PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      MDENOLD = OLD TIME PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      XVEL =    PHASE DARCY VELOCITY (FT/DAY, REAL*8)
C      XVELOLD = OLD TIME PHASE DARCY VELOCITY (FT/DAY, REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XCPL =    FLUID PHASE ISOBARIC SPECIFIC HEAT CAPACITY OR 
C                'SPECIFIC ENTHALPY' (BTU/LB-F, REAL*8)
C      XTCP =    RESERVOIR THERMAL CAPACITY (BTU/F, REAL*8)
C      XSLP =    SLOPES OF THERMAL ENTHALPY (BTU/QA-FT, REAL*8)
C  INPUT/OUTPUT:
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  MDEN(IDIM,JDIM,KDIM,NPH),MDENOLD(IDIM,JDIM,KDIM,NPH),
     &        XVEL(IDIM,JDIM,KDIM,NPH,3),XVELOLD(IDIM,JDIM,KDIM,NPH,3),
     &        TEMPR(IDIM,JDIM,KDIM),XCPL(IDIM,JDIM,KDIM,NPH),
     &        XHEAT(IDIM,JDIM,KDIM),TCOF(IDIM,JDIM,KDIM),
     &        XTCP(IDIM,JDIM,KDIM),XSLP(IDIM,JDIM,KDIM,NPH,3)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,IM1,J,K,IOFF,JOFF,KOFF,IERR,IPH,IL2P,IMIN
      REAL*8 TC,PHDM,PHDP,CPM,CPP,TMPM,TMPP,RCPTM,RCPTP,HFLUX,FLUX
      REAL*8 DY,DZ,DXM,DXP,DRCPT
C-----------------------------------------------------------------------
C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTADVX: READING BLKOFF!'
         STOP 13
      ENDIF

      IL2P = IL2+1
      IMIN = MAX(IL1,2)

      DO IPH = 1,NPH     

C----------setup up potential for phase IPH 
         DO K = KL1,KL2
            DO J = JL1V(K),JL2V(K)
               DO I = IMIN,IL2P
                  IM1 = I-1
                  TC = TCOF(I,J,K)
                  IF(TC == ZERO .OR. IM1 <= 0) CYCLE
                  IF(KEYOUT(I,J,K)/=0 .AND. KEYOUT(IM1,J,K)==0) CYCLE
                  IF(KEYOUT(I,J,K)==0 .AND. KEYOUT(IM1,J,K)/=0) CYCLE
                  IF(KEYOUT(I,J,K)==0 .AND. KEYOUT(IM1,J,K)==0) CYCLE
                  FLUX = XVELOLD(I,J,K,IPH,1)+THTFAC*(XVEL(I,J,K,IPH,1)
     &                  -XVELOLD(I,J,K,IPH,1))
                  IF(XDARCYFLUX) THEN
                     FLUX = FLUX*THDTIM
                  ELSE
                     DY = DYREC(J+JOFF,NBLK)
                     DZ = DZREC(K+KOFF,NBLK)
                     FLUX = FLUX*DY*DZ*THDTIM
                  ENDIF

                  IF(FLUX > ZERO .AND. KEYOUT(IM1,J,K) /= 0) THEN
                     DXM = DXREC(IM1+IOFF,NBLK)
                     PHDM = MDENOLD(IM1,J,K,IPH)+THTFAC
     &                    *(MDEN(IM1,J,K,IPH)-MDENOLD(IM1,J,K,IPH))
                     CPM = XCPL(IM1,J,K,IPH)
                     TMPM = TEMPR(IM1,J,K)
                     RCPTM = PHDM*CPM*TMPM
                     DRCPT = HALF*FLXLMTR*XSLP(IM1,J,K,IPH,1)*DXM
                     HFLUX = FLUX*(RCPTM+DRCPT)
                  ELSEIF(FLUX < ZERO .AND. KEYOUT(I,J,K) /= 0) THEN
                     DXP = DXREC(I+IOFF,NBLK)
                     PHDP = MDENOLD(I,J,K,IPH)+THTFAC*(MDEN(I,J,K,IPH)
     &                     -MDENOLD(I,J,K,IPH))
                     CPP = XCPL(I,J,K,IPH)
                     TMPP = TEMPR(I,J,K)
                     RCPTP = PHDP*CPP*TMPP
                     DRCPT = -HALF*FLXLMTR*XSLP(I,J,K,IPH,1)*DXP
                     HFLUX = FLUX*(RCPTP+DRCPT)
                  ELSE
                     HFLUX = ZERO
                  ENDIF

                  IF(KEYOUT(I,J,K) > 0) THEN
                     IF(XTHCFLCHK .AND. (DABS(HFLUX) >= 
     &                  DABS(XHEAT(I,J,K)))) THEN
                        XTHCFLERR = .TRUE.
                        THCFLSTEP = DABS(XHEAT(I,J,K)/HFLUX)
                     ENDIF
                     XHEAT(I,J,K) = XHEAT(I,J,K) + HFLUX
                  ENDIF
                  IF(KEYOUT(IM1,J,K) > 0) THEN
                     IF(XTHCFLCHK .AND. (DABS(HFLUX) > 
     &                  DABS(XHEAT(IM1,J,K)))) THEN
                        XTHCFLERR = .TRUE.
                        THCFLSTEP = DABS(XHEAT(IM1,J,K)/HFLUX)
                     ENDIF
                     XHEAT(IM1,J,K) = XHEAT(IM1,J,K) - HFLUX
                  ENDIF
               END DO
            END DO
         END DO
      END DO 

      RETURN
      END


C***********************************************************************
      SUBROUTINE XTADVY(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,MDEN,MDENOLD,XVEL,XVELOLD,
     &                  TEMPR,XCPL,XHEAT,XTCP,XSLP)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE EVALUATES Y-TRANSPORT OF HEAT BY ADVECTION, UPDATES XHEAT. 
C  INPUT:
C      TCOF =    Y-TRANSMISSIBILITY (CU-FT-CP/PSI-DAY, REAL*8)
C      MDEN =    PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      MDENOLD = OLD TIME PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      XVEL =    PHASE DARCY VELOCITY (FT/DAY, REAL*8)
C      XVELOLD = OLD TIME PHASE DARCY VELOCITY (FT/DAY, REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XCPL =    FLUID PHASE ISOBARIC SPECIFIC HEAT CAPACITY OR 
C                'SPECIFIC ENTHALPY' (BTU/LB-F, REAL*8)
C      XTCP =    RESERVOIR THERMAL CAPACITY (BTU/F, REAL*8)
C      XSLP =    SLOPES OF THERMAL ENTHALPY (BTU/QA-FT, REAL*8)
C  INPUT/OUTPUT:
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  MDEN(IDIM,JDIM,KDIM,NPH),MDENOLD(IDIM,JDIM,KDIM,NPH),
     &        XVEL(IDIM,JDIM,KDIM,NPH,3),XVELOLD(IDIM,JDIM,KDIM,NPH,3),
     &        TEMPR(IDIM,JDIM,KDIM),XCPL(IDIM,JDIM,KDIM,NPH),
     &        XHEAT(IDIM,JDIM,KDIM),TCOF(IDIM,JDIM,KDIM),
     &        XTCP(IDIM,JDIM,KDIM),XSLP(IDIM,JDIM,KDIM,NPH,3)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,JM1,JP1,K,IOFF,JOFF,KOFF,IERR,IPH
      REAL*8 TC,PHDM,PHDP,CPM,CPP,TMPM,TMPP,RCPTM,RCPTP,HFLUX,FLUX
      REAL*8 DX,DZ,DYM,DYP,DRCPT
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTADVY: READING BLKOFF!'
         STOP 13
      ENDIF

      DO IPH = 1,NPH     

C----------setup up potential for phase IPH 
         DO K = KL1,KL2
            DO J = JL1V(K),JL2V(K)+1
               JM1 = J-1
               IF(JM1 <= 0) CYCLE
               DO I = IL1,IL2
                  TC = TCOF(I,J,K)
                  IF(TC == ZERO) CYCLE
                  IF(KEYOUT(I,J,K)/=0 .AND. KEYOUT(I,JM1,K)==0) CYCLE
                  IF(KEYOUT(I,J,K)==0 .AND. KEYOUT(I,JM1,K)/=0) CYCLE
                  IF(KEYOUT(I,J,K)==0 .AND. KEYOUT(I,JM1,K)==0) CYCLE
                  FLUX = XVELOLD(I,J,K,IPH,2)+THTFAC*(XVEL(I,J,K,IPH,2)
     &                  -XVELOLD(I,J,K,IPH,2))
                  IF(XDARCYFLUX) THEN
                     FLUX = FLUX*THDTIM
                  ELSE
                     DX = DXREC(I+IOFF,NBLK)
                     DZ = DZREC(K+KOFF,NBLK)
                     FLUX = FLUX*DX*DZ*THDTIM
                  ENDIF

                  IF(FLUX > ZERO .AND. KEYOUT(I,JM1,K) /= 0) THEN
                     DYM = DYREC(JM1+JOFF,NBLK)
                     PHDM = MDENOLD(I,JM1,K,IPH)+THTFAC
     &                    *(MDEN(I,JM1,K,IPH)-MDENOLD(I,JM1,K,IPH))
                     CPM = XCPL(I,JM1,K,IPH)
                     TMPM = TEMPR(I,JM1,K)
                     RCPTM = PHDM*CPM*TMPM
                     DRCPT = HALF*FLXLMTR*XSLP(I,JM1,K,IPH,2)*DYM
                     HFLUX = FLUX*(RCPTM+DRCPT)
                  ELSEIF(FLUX < ZERO .AND. KEYOUT(I,J,K) /= 0) THEN
                     DYP = DYREC(J+JOFF,NBLK)
                     PHDP = MDENOLD(I,J,K,IPH)+THTFAC
     &                    *(MDEN(I,J,K,IPH)-MDENOLD(I,J,K,IPH))
                     CPP = XCPL(I,J,K,IPH)
                     TMPP = TEMPR(I,J,K)
                     RCPTP = PHDP*CPP*TMPP
                     DRCPT = -HALF*FLXLMTR*XSLP(I,J,K,IPH,2)*DYP
                     HFLUX = FLUX*(RCPTP+DRCPT)
                  ELSE
                     HFLUX = ZERO
                  ENDIF

                  IF(KEYOUT(I,J,K) > 0) THEN
                     IF(XTHCFLCHK .AND. (DABS(HFLUX) >= 
     &                  DABS(XHEAT(I,J,K)))) THEN
                        XTHCFLERR = .TRUE.
                        THCFLSTEP = DABS(XHEAT(I,J,K)/HFLUX)
                     ENDIF
                     XHEAT(I,J,K) = XHEAT(I,J,K) + HFLUX
                  ENDIF
                  IF(KEYOUT(I,JM1,K) > 0) THEN
                     IF(XTHCFLCHK .AND. (DABS(HFLUX) > 
     &                  DABS(XHEAT(I,JM1,K)))) THEN
                        XTHCFLERR = .TRUE.
                        THCFLSTEP = DABS(XHEAT(I,JM1,K)/HFLUX)
                     ENDIF
                     XHEAT(I,JM1,K) = XHEAT(I,JM1,K) - HFLUX
                  ENDIF
               END DO
            END DO
         END DO
      END DO 

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTADVZ(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,MDEN,MDENOLD,XVEL,XVELOLD,
     &                  TEMPR,XCPL,XHEAT,XTCP,XSLP)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE EVALUATES Z-TRANSPORT OF HEAT BY ADVECTION, UPDATES XHEAT. 
C  INPUT:
C      TCOF =    Z-TRANSMISSIBILITY (CU-FT-CP/PSI-DAY, REAL*8)
C      MDEN =    PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      MDENOLD = OLD TIME PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      XVEL =    PHASE DARCY VELOCITY (FT/DAY, REAL*8)
C      XVELOLD = OLD TIME PHASE DARCY VELOCITY (FT/DAY, REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XCPL =    FLUID PHASE ISOBARIC SPECIFIC HEAT CAPACITY OR 
C                'SPECIFIC ENTHALPY' (BTU/LB-F, REAL*8)
C      XTCP =    RESERVOIR THERMAL CAPACITY (BTU/F, REAL*8)
C      XSLP =    SLOPES OF THERMAL ENTHALPY (BTU/QA-FT, REAL*8)
C  INPUT/OUTPUT:
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  MDEN(IDIM,JDIM,KDIM,NPH),MDENOLD(IDIM,JDIM,KDIM,NPH),
     &        XVEL(IDIM,JDIM,KDIM,NPH,3),XVELOLD(IDIM,JDIM,KDIM,NPH,3),
     &        TEMPR(IDIM,JDIM,KDIM),XCPL(IDIM,JDIM,KDIM,NPH),
     &        XHEAT(IDIM,JDIM,KDIM),TCOF(IDIM,JDIM,KDIM),
     &        XTCP(IDIM,JDIM,KDIM),XSLP(IDIM,JDIM,KDIM,NPH,3)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,JL1(KDIM),JL2(KDIM),K,KM1,IOFF,JOFF,KOFF,IERR,IPH,
     &        KL1S,KL2P
      REAL*8 TC,PHDM,PHDP,CPM,CPP,TMPM,TMPP,RCPTM,RCPTP,HFLUX,FLUX
      REAL*8 DX,DY,DZM,DZP,DRCPT
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTADVZ: READING BLKOFF!'
         STOP 13
      ENDIF

      KL2P = KL2+1
      KL1S = MAX(KL1,2)

C-------set up JL1 and JL2 vectors
      JL1(KL1)=JL1V(KL1)
      JL2(KL1)=JL2V(KL1)
      DO K = KL1+1,KL2
         JL1(K)=MIN(JL1V(K-1),JL1V(K))
         JL2(K)=MAX(JL2V(K-1),JL2V(K))
      END DO
      JL1(KL2P)=JL1V(KL2)
      JL2(KL2P)=JL2V(KL2)

      DO IPH = 1,NPH     

C----------setup up potential for phase IPH 
         DO K = KL1S,KL2P
            KM1 = K-1
            IF(KM1 <= 0) CYCLE
            DO J = JL1(K),JL2(K)
               DO I = IL1,IL2
                  TC = TCOF(I,J,K)
                  IF(TC == ZERO) CYCLE
                  IF(KEYOUT(I,J,K)/=0 .AND. KEYOUT(I,J,KM1)==0) CYCLE
                  IF(KEYOUT(I,J,K)==0 .AND. KEYOUT(I,J,KM1)/=0) CYCLE
                  IF(KEYOUT(I,J,K)==0 .AND. KEYOUT(I,J,KM1)==0) CYCLE
                  FLUX = XVELOLD(I,J,K,IPH,3)+THTFAC*(XVEL(I,J,K,IPH,3)
     &                  -XVELOLD(I,J,K,IPH,3))
                  IF(XDARCYFLUX) THEN
                     FLUX = FLUX*THDTIM
                  ELSE
                     DX = DXREC(I+IOFF,NBLK)
                     DY = DYREC(J+JOFF,NBLK)
                     FLUX = FLUX*DX*DY*THDTIM
                  ENDIF

                  IF(FLUX > ZERO .AND. KEYOUT(I,J,KM1) /= 0) THEN
                     DZM = DZREC(KM1+KOFF,NBLK)
                     PHDM = MDENOLD(I,J,KM1,IPH)+THTFAC
     &                    *(MDEN(I,J,KM1,IPH)-MDENOLD(I,J,KM1,IPH))
                     CPM = XCPL(I,J,KM1,IPH)
                     TMPM = TEMPR(I,J,KM1)
                     RCPTM = PHDM*CPM*TMPM
                     DRCPT = HALF*FLXLMTR*XSLP(I,J,KM1,IPH,3)*DZM
                     HFLUX = FLUX*(RCPTM+DRCPT)
                  ELSEIF(FLUX < ZERO .AND. KEYOUT(I,J,K) /= 0) THEN
                     DZP = DZREC(K+KOFF,NBLK)
                     PHDP = MDENOLD(I,J,K,IPH)+THTFAC
     &                    *(MDEN(I,J,K,IPH)-MDENOLD(I,J,K,IPH))
                     CPP = XCPL(I,J,K,IPH)
                     TMPP = TEMPR(I,J,K)
                     RCPTP = PHDP*CPP*TMPP
                     DRCPT = -HALF*FLXLMTR*XSLP(I,J,K,IPH,3)*DZP
                     HFLUX = FLUX*(RCPTP+DRCPT)
                  ELSE
                     HFLUX = ZERO
                  ENDIF

                  IF(KEYOUT(I,J,K) > 0) THEN
                     IF(XTHCFLCHK .AND. (DABS(HFLUX) >= 
     &                  DABS(XHEAT(I,J,K)))) THEN
                        XTHCFLERR = .TRUE.
                        THCFLSTEP = DABS(XHEAT(I,J,K)/HFLUX)
                     ENDIF
                     XHEAT(I,J,K) = XHEAT(I,J,K) + HFLUX
                  ENDIF
                  IF(KEYOUT(I,J,KM1) > 0) THEN
                     IF(XTHCFLCHK .AND. (DABS(HFLUX) > 
     &                  DABS(XHEAT(I,J,KM1)))) THEN
                        XTHCFLERR = .TRUE.
                        THCFLSTEP = DABS(XHEAT(I,J,KM1)/HFLUX)
                     ENDIF
                     XHEAT(I,J,KM1) = XHEAT(I,J,KM1) - HFLUX
                  ENDIF
               END DO
            END DO
         END DO
      END DO 

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTDFFA(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                 KEYOUT,NBLK,RHOS,XCVS,XCVL,PV,PVOLD,MDEN,MDENOLD,
     &                 SAT,SATOLD,TEMPR,XHEAT,XTCOF,XTRESID,XTDUNK)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE SETS UP ACCUMULATION TERM OF HEAT DIFFUSION EQUATION 
C  AND INITIAL GUESS.
C  INPUT:
C      PV(OLD) =   (OLD TIME) PORE VOLUME (CU-FT, REAL*8)
C      MDEN(OLD) = (OLD TIME) PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      SAT(OLD) =  (OLD TIME) PHASE SATURATIONS (REAL*8)
C      RHOS =      RESERVOIR ROCK MASS DENSITY (LB/CU-FT, REAL*8)
C      XCVS =      RESERVOIR ROCK CONSTANT VOLUME SPECIFIC HEAT
C                  CAPACITY (BTU/LB-F, REAL*8)
C      XCVL =      PHASE CONSTANT VOLUME SPECIFIC HEAT CAPACITY
C                  (BTU/LB-F, REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C  OUTPUT:
C      XTCOF =   HEAT (DIFFUSION) EQUATION STIFFNESS MATRIX (REAL*4)
C      XTRESID = HEAT (DIFFUSION) EQUATION R.H.S (REAL*8)
C      XTDUNK =  HEAT (DIFFUSION) EQUATION SOLUTION GUESS 
C                (DEGREES F, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*4  XTCOF(IDIM,JDIM,KDIM,$NUMCOF)
      REAL*8  TEMPR(IDIM,JDIM,KDIM),XHEAT(IDIM,JDIM,KDIM),
     &        XTRESID(IDIM,JDIM,KDIM),XTDUNK(IDIM,JDIM,KDIM),
     &        RHOS(IDIM,JDIM,KDIM),XCVS(IDIM,JDIM,KDIM),
     &        XCVL(IDIM,JDIM,KDIM,NPH),PV(IDIM,JDIM,KDIM),
     &        PVOLD(IDIM,JDIM,KDIM),MDEN(IDIM,JDIM,KDIM,NPH),
     &        MDENOLD(IDIM,JDIM,KDIM,NPH),SAT(IDIM,JDIM,KDIM,NPH),
     &        SATOLD(IDIM,JDIM,KDIM,NPH)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,JL1,JL2,K,L,IOFF,JOFF,KOFF,IERR,IPH
      REAL*8 DX,DY,DZ,PRV,PHDENS,PHSAT,VOL,XTCPC,PVI,SATI,MDENI
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTDFFA: READING BLKOFF!'
         STOP 13
      ENDIF

C  SET-UP ACCUMULATION TERM OF STIFFNESS MATRIX - XTCOF, XTRESID AND GUESS
      DO K=KL1,KL2
         JL1=JL1V(K)
         JL2=JL2V(K)
         DO J=JL1,JL2
            DO I=IL1,IL2
               XTCPC = ZERO
               IF(KEYOUT(I,J,K) <= 0) CYCLE
               DO L=1,$NUMCOF
                  XTCOF(I,J,K,L)=SZERO
                  XTRESID(I,J,K)=ZERO
               END DO
               DX=DXREC(I+IOFF,NBLK)
               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               VOL=DX*DY*DZ
               PVI=PVOLD(I,J,K)+THTFAC*(PV(I,J,K)-PVOLD(I,J,K))
               XTCPC=XTCPC+(VOL-PVI)*RHOS(I,J,K)*XCVS(I,J,K)
               DO IPH=1,NPH
                  SATI=SATOLD(I,J,K,IPH)+THTFAC*(SAT(I,J,K,IPH)
     &                                          -SATOLD(I,J,K,IPH))
                  MDENI=MDENOLD(I,J,K,IPH)+THTFAC*(MDEN(I,J,K,IPH)
     &                                            -MDENOLD(I,J,K,IPH))
                  XTCPC=XTCPC+PVI*MDENI*SATI*XCVL(I,J,K,IPH)
               END DO
               XTCOF(I,J,K,1)=XTCPC
               XTRESID(I,J,K)=XHEAT(I,J,K)
               XTDUNK(I,J,K)=TEMPR(I,J,K)
            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTDFFBD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                   KEYOUT,NBLK,TEMPR,XTCOND,XTCOF,XTRESID,XHEAT)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE TREATS HEAT LOSS TO OVER- AND UNDER-BURDEN ROCKS BY 
C  DIFFUSION, BY SETTING XTCOF,XTRESID (IMPLICIT OPTION SET ACTIVE).
C  INPUT:
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XTCOND =  THERMAL CONDUCTIVITY (BTU/FT-DAY-F,REAL*8)
C  INPUT/OUTPUT:
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C  OUTPUT:
C      XTCOF =   STIFFNESS MATRIX FOR HEAT DIFFUSION EQUATION (REAL*4)
C      XTRESID = RIGHT HAND SIDE FOR HEAT DIFFUSION EQUATION (REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*4  XTCOF(IDIM,JDIM,KDIM,$NUMCOF)
      REAL*8  TEMPR(IDIM,JDIM,KDIM),XTCOND(IDIM,JDIM,KDIM,3),
     &        XHEAT(IDIM,JDIM,KDIM),XTRESID(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,IG,IM1,IP1,J,JG,JL1,JL2,K,KG,L,IOFF,JOFF,KOFF,IERR
      REAL*8 DX,DY,DZ,TC,TOB,TUB,XBD,FCOND,HFLUX,HFLUXR,TRES
      REAL*8 DCONST,KCONST,KDCONST,TCF1,TCF2,TCF3,TI,XTRES,HLFTIM
      LOGICAL TOPEL,BOTEL
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTDFFBD: READING BLKOFF!'
         STOP 13
      ENDIF

      DO K=KL1,KL2
         JL1=JL1V(K)
         JL2=JL2V(K)
         DO J=JL1,JL2
            DO I=IL1,IL2
               IM1=I-1
               IP1=I+1
               TOPEL=.FALSE.
               BOTEL=.FALSE.
               IF((KEYOUT(I,J,K) > 0 .AND. KEYOUT(IM1,J,K) /= 0 .AND.
     &             KEYOUT(IP1,J,K) /= 0) .OR. KEYOUT(I,J,K) <= 0) THEN
                  CYCLE
               ELSE
                  IF(KEYOUT(I,J,K) > 0 .AND. KEYOUT(IM1,J,K) == 0) 
     &            TOPEL=.TRUE.
                  IF(KEYOUT(I,J,K) > 0 .AND. KEYOUT(IP1,J,K) == 0) 
     &            BOTEL=.TRUE.
               ENDIF

               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               TRES=TEMPR(I,J,K)
               IF(TOPEL) THEN
                  IG=I+IOFF
                  JG=J+JOFF
                  KG=K+JOFF
C                  XBD=XREC(IG,NBLK)
                  XBD=DOWN(1,NBLK)*XREC(IG,NBLK)
     &               +DOWN(2,NBLK)*(YREC(JG,NBLK)+YREC(JG+1,NBLK))
     &               +DOWN(3,NBLK)*(ZREC(KG,NBLK)+ZREC(KG+1,NBLK))
                  XBD=XBD-DBDINFTY
                  TOB=TMPOB+DPTHTGRD*(XBD-XRFOB)
                  XTRES=XTRESID(IM1,J,K)
                  IF(DABS(TRES-TOB) > TEN_M6 .AND. XTRES < ZERO) THEN
                     XTRESID(IM1,J,K)=TEN_M6*(THTIM_NEW-THDTIM)
                     XTRES=XTRESID(IM1,J,K)
                  ENDIF  
                  IF(XTRES < ZERO .OR. DABS(TRES-TOB) <= TEN_M6) 
     &            GOTO 100
                  HLFTIM=THTIM_NEW-TEN_P6*XTRES
                  DCONST=XTCOND(IM1,J,K,1)*HLFTIM
                  DCONST=HALF*DSQRT(DCONST/(RHOOB*CVOB))
                  TCF1=XTCOND(IM1,J,K,1)*THDTIM/DCONST
                  KCONST=XTCOND(IM1,J,K,1)/(RHOOB*CVOB)
                  KDCONST=THREE*(DCONST**TWO)+KCONST*THDTIM
                  TCF2=(XTCOND(IM1,J,K,1)*KCONST*THDTIM)*THDTIM
     &                /(DCONST*KDCONST)
                  TCF3=(XTCOND(IM1,J,K,1)*(DCONST**THREE))*THDTIM
     &                /(KCONST*KDCONST*THDTIM)
                  TI=(XTCOND(IM1,J,K,1)*XHEAT(IM1,J,K)*THDTIM)/KDCONST
                  HFLUX=-(TCF1-TCF2+TCF3)*DY*DZ
                  HFLUXR=-(-TCF1*TOB+TCF2*TOB-TI-TCF3*TRES)*DY*DZ
C                  HFLUX=-(TCF1-TCF2+TCF3)
C                  HFLUXR=-(-TCF1*TOB+TCF2*TOB-TI-TCF3*TRES)
                  XTCOF(I,J,K,1)=XTCOF(I,J,K,1)-HFLUX
                  XTRESID(I,J,K)=XTRESID(I,J,K)+HFLUXR
               ENDIF

  100          CONTINUE

               IF(BOTEL) THEN
                  IG=IP1+IOFF
                  JG=J+JOFF
                  KG=K+KOFF
C                  XBD=XREC(IG,NBLK)
                  XBD=DOWN(1,NBLK)*XREC(IG,NBLK)
     &               +DOWN(2,NBLK)*(YREC(JG,NBLK)+YREC(JG+1,NBLK))
     &               +DOWN(3,NBLK)*(ZREC(KG,NBLK)+ZREC(KG+1,NBLK))
     &               +DBDINFTY
                  TUB=TMPOB+DPTHTGRD*(XBD-XRFOB)
                  XTRES=XTRESID(IP1,J,K)
                  IF(DABS(TRES-TUB) > TEN_M6 .AND. XTRES < ZERO) THEN
                     XTRESID(IP1,J,K)=TEN_M6*(THTIM_NEW-THDTIM)
                     XTRES=XTRESID(IP1,J,K)
                  ENDIF  
                  IF(XTRES < ZERO .OR. DABS(TRES-TUB) <= TEN_M6) 
     &            GOTO 200
                  HLFTIM=THTIM_NEW-TEN_P6*XTRES
                  DCONST=XTCOND(IP1,J,K,1)*HLFTIM
                  DCONST=HALF*DSQRT(DCONST/(RHOUB*CVUB))
                  TCF1=XTCOND(IP1,J,K,1)*THDTIM/DCONST
                  KCONST=XTCOND(IP1,J,K,1)/(RHOUB*CVUB)
                  KDCONST=THREE*(DCONST**TWO)+KCONST*THDTIM
                  TCF2=(XTCOND(IP1,J,K,1)*KCONST*THDTIM)*THDTIM
     &                /(DCONST*KDCONST)
                  TCF3=(XTCOND(IP1,J,K,1)*(DCONST**THREE))*THDTIM
     &                /(KCONST*KDCONST*THDTIM)
                  TI=(XTCOND(IP1,J,K,1)*XHEAT(IP1,J,K)*THDTIM)/KDCONST
                  HFLUX=-(TCF1-TCF2+TCF3)*DY*DZ
                  HFLUXR=-(TCF1*TUB-TCF2*TUB+TI+TCF3*TRES)*DY*DZ
C                  HFLUX=-(TCF1-TCF2+TCF3)
C                  HFLUXR=-(TCF1*TUB-TCF2*TUB+TI+TCF3*TRES)
                  XTCOF(I,J,K,1)=XTCOF(I,J,K,1)-HFLUX
                  XTRESID(I,J,K)=XTRESID(I,J,K)-HFLUXR
               ENDIF

  200          CONTINUE
            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTUPDBD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                   KEYOUT,NBLK,TEMPR,XTCOND,XTRESID,XHEAT)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE UPDATES EXPLICIT TERMS FOR HEATLOSS TO OVER- AND UNDER-
C  BURDEN ROCKS BY DIFFUSION, REQUIRED IN SUBSEQUENT SOLVE.
C  INPUT:
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XTCOND =  THERMAL CONDUCTIVITY (BTU/FT-DAY-F,REAL*8)
C  INPUT/OUTPUT:
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*4  XTCOF(IDIM,JDIM,KDIM,$NUMCOF)
      REAL*8  TEMPR(IDIM,JDIM,KDIM),XTCOND(IDIM,JDIM,KDIM,3),
     &        XHEAT(IDIM,JDIM,KDIM),XTRESID(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,IG,IM1,IP1,J,JG,JL1,JL2,K,KG,L,IOFF,JOFF,KOFF,IERR
      REAL*8 DX,DY,DZ,TC,TOB,TUB,XBD,FCOND,HLFTIM,TI,TP,TQ
      REAL*8 DCONST,KCONST,KDCONST,TCF1,TCF2,TCF3,TRES,XTRES
      LOGICAL TOPEL,BOTEL
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTDFFBD: READING BLKOFF!'
         STOP 13
      ENDIF

      DO K=KL1,KL2
         JL1=JL1V(K)
         JL2=JL2V(K)
         DO J=JL1,JL2
            DO I=IL1,IL2
               IM1=I-1
               IP1=I+1
               TOPEL=.FALSE.
               BOTEL=.FALSE.
               IF((KEYOUT(I,J,K) > 0 .AND. KEYOUT(IM1,J,K) /= 0 .AND.
     &             KEYOUT(IP1,J,K) /= 0) .OR. KEYOUT(I,J,K) <= 0) THEN
                  CYCLE
               ELSE
                  IF(KEYOUT(I,J,K) > 0 .AND. KEYOUT(IM1,J,K) == 0) 
     &            TOPEL=.TRUE.
                  IF(KEYOUT(I,J,K) > 0 .AND. KEYOUT(IP1,J,K) == 0) 
     &            BOTEL=.TRUE.
               ENDIF

               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               TRES=TEMPR(I,J,K)
               IF(TOPEL) THEN
                  IG=I+IOFF
                  JG=J+JOFF
                  KG=K+JOFF
C                  XBD=XREC(IG,NBLK)
                  XBD=DOWN(1,NBLK)*XREC(IG,NBLK)
     &               +DOWN(2,NBLK)*(YREC(JG,NBLK)+YREC(JG+1,NBLK))
     &               +DOWN(3,NBLK)*(ZREC(KG,NBLK)+ZREC(KG+1,NBLK))
                  XBD=XBD-DBDINFTY
                  TOB=TMPOB+DPTHTGRD*(XBD-XRFOB)
                  XTRES=XTRESID(IM1,J,K)
                  IF(XTRES < ZERO .OR. DABS(TRES-TOB) <= TEN_M6) 
     &            GOTO 100
                  HLFTIM=THTIM_NEW-TEN_P6*XTRES
                  DCONST=XTCOND(IM1,J,K,1)*HLFTIM
                  DCONST=HALF*DSQRT(DCONST/(RHOOB*CVOB))
                  KCONST=XTCOND(IM1,J,K,1)/(RHOOB*CVOB)
                  KDCONST=THREE*(DCONST**TWO)+KCONST*THDTIM
                  TCF1=(KCONST*THDTIM)/(DCONST*KDCONST)
                  TCF2=(DCONST**THREE)/(KCONST*KDCONST*THDTIM)
                  TI=XHEAT(IM1,J,K)/KDCONST
                  TP=TCF1*(TRES-TOB)+TI-TCF2*TEMPR(IM1,J,K)
                  TQ=TP/DCONST-HALF*(TRES-TOB)/(DCONST**TWO)
     &              +HALF*TEMPR(IM1,J,K)/(KCONST*THDTIM)
                  XHEAT(IM1,J,K)=(TRES-TOB)*DCONST+TP*(DCONST**TWO)
     &                          +TQ*(DCONST**THREE)
               ENDIF

  100          CONTINUE

               IF(BOTEL) THEN
                  IG=IP1+IOFF
                  JG=J+JOFF
                  KG=K+KOFF
C                  XBD=XREC(IG,NBLK)
                  XBD=DOWN(1,NBLK)*XREC(IG,NBLK)
     &               +DOWN(2,NBLK)*(YREC(JG,NBLK)+YREC(JG+1,NBLK))
     &               +DOWN(3,NBLK)*(ZREC(KG,NBLK)+ZREC(KG+1,NBLK))
     &               +DBDINFTY
                  TUB=TMPOB+DPTHTGRD*(XBD-XRFOB)
                  XTRES=XTRESID(IP1,J,K)
                  IF(XTRES < ZERO .OR. DABS(TRES-TUB) <= TEN_M6) 
     &            GOTO 200
                  HLFTIM=THTIM_NEW-TEN_P6*XTRES
                  DCONST=XTCOND(IP1,J,K,1)*HLFTIM
                  DCONST=HALF*DSQRT(DCONST/(RHOUB*CVUB))
                  KCONST=XTCOND(IP1,J,K,1)/(RHOUB*CVUB)
                  KDCONST=THREE*(DCONST**TWO)+KCONST*THDTIM
                  TCF1=(KCONST*THDTIM)/(DCONST*KDCONST)
                  TCF2=(DCONST**THREE)/(KCONST*KDCONST*THDTIM)
                  TI=XHEAT(IP1,J,K)/KDCONST
                  TP=TCF1*(TRES-TUB)+TI-TCF2*TEMPR(IP1,J,K)
                  TQ=TP/DCONST-HALF*(TRES-TUB)/(DCONST**TWO)
     &              +HALF*TEMPR(IP1,J,K)/(KCONST*THDTIM)
                  XHEAT(IP1,J,K)=(TRES-TUB)*DCONST+TP*(DCONST**TWO)
     &                          +TQ*(DCONST**THREE)
               ENDIF

  200          CONTINUE
            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTDFFX(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,TEMPR,XTCOND,XTCOF,XTRESID,
     &                  XHEAT)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE TREATS X-TRANSPORT OF HEAT BY DIFFUSION, UPDATES XHEAT.
C  SOLVES SYSTEM BY SETTING XTCOF,XTRESID IF IMPLICIT OPTION ACTIVE.
C  INPUT:
C      TCOF =    X-TRANSMISSIBILITY (CU-FT-CP/PSI-DAY, REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XTCOND =  THERMAL CONDUCTIVITY (BTU/FT-DAY-F,REAL*8)
C  INPUT/OUTPUT:
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C  OUTPUT:
C      XTCOF =   STIFFNESS MATRIX FOR HEAT DIFFUSION EQUATION (REAL*4)
C      XTRESID = RIGHT HAND SIDE FOR HEAT DIFFUSION EQUATION (REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*4  XTCOF(IDIM,JDIM,KDIM,$NUMCOF)
      REAL*8  TEMPR(IDIM,JDIM,KDIM),XTCOND(IDIM,JDIM,KDIM,3),
     &        XHEAT(IDIM,JDIM,KDIM),TCOF(IDIM,JDIM,KDIM),
     &        XTRESID(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,IM1,J,JL1,JL2,K,L,IOFF,JOFF,KOFF,IERR,IL2P,IMIN
      REAL*8 DX,DY,DZ,TC,DELT,FCOND,HFLUX,FLUX
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTDFFX: READING BLKOFF!'
         STOP 13
      ENDIF

      IL2P = IL2+1
      IMIN = MAX(IL1,2)

      DO K=KL1,KL2
         JL1=JL1V(K)
         JL2=JL2V(K)
         DO J=JL1,JL2
            DO I=IMIN,IL2P
               IM1=I-1
               TC=TCOF(I,J,K)
               IF(TC == ZERO .OR. IM1 <= 0) CYCLE
               IF(KEYOUT(I,J,K) /= 0 .AND. KEYOUT(IM1,J,K) == 0) CYCLE
               IF(KEYOUT(I,J,K) == 0 .AND. KEYOUT(IM1,J,K) /= 0) CYCLE
               IF(KEYOUT(I,J,K) == 0 .AND. KEYOUT(IM1,J,K) == 0) CYCLE
               DX=HALF*(DXREC(I+IOFF,NBLK)+DXREC(IM1+IOFF,NBLK))
               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               DELT=TEMPR(I,J,K)-TEMPR(IM1,J,K)
               FCOND=HALF*(XTCOND(I,J,K,1)+XTCOND(IM1,J,K,1))*THDTIM
               HFLUX=-(FCOND/DX)*DY*DZ
               IF(KEYOUT(I,J,K) > 0) THEN
                  IF(XTHSOLVE) THEN
                     XTCOF(I,J,K,1)=XTCOF(I,J,K,1)-THSOLTHTA*HFLUX
                     XTCOF(I,J,K,2)=XTCOF(I,J,K,2)+THSOLTHTA*HFLUX
                     XTRESID(I,J,K)=XTRESID(I,J,K)
     &                           +(ONE-THSOLTHTA)*HFLUX*DELT
                  ELSE
                     XHEAT(I,J,K)=XHEAT(I,J,K)+HFLUX*DELT
                  ENDIF
               ENDIF
               IF(KEYOUT(IM1,J,K) > 0) THEN
                  IF(XTHSOLVE) THEN
                     XTCOF(IM1,J,K,1)=XTCOF(IM1,J,K,1)-THSOLTHTA*HFLUX
                     XTCOF(IM1,J,K,3)=XTCOF(IM1,J,K,3)+THSOLTHTA*HFLUX
                     XTRESID(IM1,J,K)=XTRESID(IM1,J,K)
     &                           -(ONE-THSOLTHTA)*HFLUX*DELT
                  ELSE
                     XHEAT(IM1,J,K)=XHEAT(IM1,J,K)-HFLUX*DELT
                  ENDIF
               ENDIF

            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTDFFY(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,TEMPR,XTCOND,XTCOF,XTRESID,
     &                  XHEAT)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE TREATS Y-TRANSPORT OF HEAT BY DIFFUSION, UPDATES XHEAT.
C  SOLVES SYSTEM BY SETTING XTCOF,XTRESID IF IMPLICIT OPTION ACTIVE.
C  INPUT:
C      TCOF =    Y-TRANSMISSIBILITY (CU-FT-CP/PSI-DAY, REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XTCOND =  THERMAL CONDUCTIVITY (BTU/FT-DAY-F,REAL*8)
C  INPUT/OUTPUT:
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C  OUTPUT:
C      XTCOF =   STIFFNESS MATRIX FOR HEAT DIFFUSION EQUATION (REAL*4)
C      XTRESID = RIGHT HAND SIDE FOR HEAT DIFFUSION EQUATION (REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*4  XTCOF(IDIM,JDIM,KDIM,$NUMCOF)
      REAL*8  TEMPR(IDIM,JDIM,KDIM),XTCOND(IDIM,JDIM,KDIM,3),
     &        XHEAT(IDIM,JDIM,KDIM),TCOF(IDIM,JDIM,KDIM),
     &        XTRESID(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,JM1,K,L,IOFF,JOFF,KOFF,IERR
      REAL*8 DX,DY,DZ,TC,DELT,FCOND,HFLUX,FLUX
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTDFFY: READING BLKOFF!'
         STOP 13
      ENDIF

      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)+1
            JM1=J-1
            IF(JM1 <= 0) CYCLE
            DO I=IL1,IL2
               TC=TCOF(I,J,K)
               IF(TC == ZERO) CYCLE
               IF(KEYOUT(I,J,K) /= 0 .AND. KEYOUT(I,JM1,K) == 0) CYCLE
               IF(KEYOUT(I,J,K) == 0 .AND. KEYOUT(I,JM1,K) /= 0) CYCLE
               IF(KEYOUT(I,J,K) == 0 .AND. KEYOUT(I,JM1,K) == 0) CYCLE
               DY=HALF*(DYREC(J+JOFF,NBLK)+DYREC(JM1+JOFF,NBLK))
               DX=DXREC(I+IOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               DELT=TEMPR(I,J,K)-TEMPR(I,JM1,K)
               FCOND=HALF*(XTCOND(I,J,K,2)+XTCOND(I,JM1,K,2))*THDTIM
               HFLUX=-(FCOND/DY)*DX*DZ
               IF(KEYOUT(I,J,K) > 0) THEN
                  IF(XTHSOLVE) THEN
                     XTCOF(I,J,K,1)=XTCOF(I,J,K,1)-THSOLTHTA*HFLUX
                     XTCOF(I,J,K,4)=XTCOF(I,J,K,4)+THSOLTHTA*HFLUX
                     XTRESID(I,J,K)=XTRESID(I,J,K)
     &                           +(ONE-THSOLTHTA)*HFLUX*DELT
                  ELSE
                     XHEAT(I,J,K)=XHEAT(I,J,K)+HFLUX*DELT
                  ENDIF
               ENDIF
               IF(KEYOUT(I,JM1,K) > 0) THEN
                  IF(XTHSOLVE) THEN
                     XTCOF(I,JM1,K,1)=XTCOF(I,JM1,K,1)-THSOLTHTA*HFLUX
                     XTCOF(I,JM1,K,5)=XTCOF(I,JM1,K,5)+THSOLTHTA*HFLUX
                     XTRESID(I,JM1,K)=XTRESID(I,JM1,K)
     &                           -(ONE-THSOLTHTA)*HFLUX*DELT
                  ELSE
                     XHEAT(I,JM1,K)=XHEAT(I,JM1,K)-HFLUX*DELT
                  ENDIF
               ENDIF

            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTDFFZ(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                  KEYOUT,NBLK,TCOF,TEMPR,XTCOND,XTCOF,XTRESID,
     &                  XHEAT)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE TREATS Z-TRANSPORT OF HEAT BY DIFFUSION, UPDATES XHEAT.
C  SOLVES SYSTEM BY SETTING XTCOF,XTRESID IF IMPLICIT OPTION ACTIVE.
C  INPUT:
C      TCOF =    Z-TRANSMISSIBILITY (CU-FT-CP/PSI-DAY, REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XTCOND =  THERMAL CONDUCTIVITY (BTU/FT-DAY-F,REAL*8)
C  INPUT/OUTPUT:
C      XHEAT =   LOCAL INTERNAL HEAT ENERGY CONTENT
C                (FT-LB/SQ-DAY, REAL*8)
C  OUTPUT:
C      XTCOF =   STIFFNESS MATRIX FOR HEAT DIFFUSION EQUATION (REAL*4)
C      XTRESID = RIGHT HAND SIDE FOR HEAT DIFFUSION EQUATION (REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*4  XTCOF(IDIM,JDIM,KDIM,$NUMCOF)
      REAL*8  TEMPR(IDIM,JDIM,KDIM),XTCOND(IDIM,JDIM,KDIM,3),
     &        XHEAT(IDIM,JDIM,KDIM),TCOF(IDIM,JDIM,KDIM),
     &        XTRESID(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,JL1(KDIM),JL2(KDIM),K,KM1,IOFF,JOFF,KOFF,IERR,
     &        KL2P,KL1S
      REAL*8 DX,DY,DZ,TC,DELT,FCOND,HFLUX,FLUX
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTDFFZ: READING BLKOFF!'
         STOP 13
      ENDIF

      KL2P = KL2+1
      KL1S = MAX(KL1,2)

C-------set up JL1 and JL2 vectors
      JL1(KL1)=JL1V(KL1)
      JL2(KL1)=JL2V(KL1)
      DO K = KL1+1,KL2
         JL1(K)=MIN(JL1V(K-1),JL1V(K))
         JL2(K)=MAX(JL2V(K-1),JL2V(K))
      END DO
      JL1(KL2P)=JL1V(KL2)
      JL2(KL2P)=JL2V(KL2)

      DO K=KL1S,KL2P
         KM1=K-1
         IF(KM1 <= 0) CYCLE
         DO J=JL1(K),JL2(K)
            DO I=IL1,IL2
               TC=TCOF(I,J,K)
               IF(TC == ZERO) CYCLE
               IF(KEYOUT(I,J,K) /= 0 .AND. KEYOUT(I,J,KM1) == 0) CYCLE
               IF(KEYOUT(I,J,K) == 0 .AND. KEYOUT(I,J,KM1) /= 0) CYCLE
               IF(KEYOUT(I,J,K) == 0 .AND. KEYOUT(I,J,KM1) == 0) CYCLE
               DZ=HALF*(DZREC(K+KOFF,NBLK)+DZREC(KM1+KOFF,NBLK))
               DX=DXREC(I+IOFF,NBLK)
               DY=DYREC(J+JOFF,NBLK)
               DELT=TEMPR(I,J,K)-TEMPR(I,J,KM1)
               FCOND=HALF*(XTCOND(I,J,K,3)+XTCOND(I,J,KM1,3))*THDTIM
               HFLUX=-(FCOND/DZ)*DX*DY
               IF(KEYOUT(I,J,K) > 0) THEN
                  IF(XTHSOLVE) THEN
                     XTCOF(I,J,K,1)=XTCOF(I,J,K,1)-THSOLTHTA*HFLUX
                     XTCOF(I,J,K,6)=XTCOF(I,J,K,6)+THSOLTHTA*HFLUX
                     XTRESID(I,J,K)=XTRESID(I,J,K)
     &                           +(ONE-THSOLTHTA)*HFLUX*DELT
                  ELSE
                     XHEAT(I,J,K)=XHEAT(I,J,K)+HFLUX*DELT
                  ENDIF
               ENDIF
               IF(KEYOUT(I,J,KM1) > 0) THEN
                  IF(XTHSOLVE) THEN
                     XTCOF(I,J,KM1,1)=XTCOF(I,J,KM1,1)-THSOLTHTA*HFLUX
                     XTCOF(I,J,KM1,7)=XTCOF(I,J,KM1,7)+THSOLTHTA*HFLUX
                     XTRESID(I,J,KM1)=XTRESID(I,J,KM1)
     &                           -(ONE-THSOLTHTA)*HFLUX*DELT
                  ELSE
                     XHEAT(I,J,KM1)=XHEAT(I,J,KM1)-HFLUX*DELT
                  ENDIF
               ENDIF

            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XUPTMPR(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                KEYOUT,NBLK,RHOS,XCVS,XCVL,PV,PVOLD,MDEN,MDENOLD,
     &                SAT,SATOLD,TEMPR,XHEAT)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE UPDATES TEMPERATURE EXPLICITLY USING XHEAT
C  INPUT:
C      PV(OLD) =   (OLD TIME) PORE VOLUME (CU-FT, REAL*8)
C      MDEN(OLD) = (OLD TIME) PHASE MASS DENSITY (LB/CU-FT, REAL*8)
C      SAT(OLD) =  (OLD TIME) PHASE SATURATIONS (REAL*8)
C      RHOS =      RESERVOIR ROCK MASS DENSITY (LB/CU-FT, REAL*8)
C      XCVS =      RESERVOIR ROCK CONSTANT VOLUME SPECIFIC HEAT 
C                  CAPACITY (BTU/LB-F, REAL*8)
C      XCVL =      PHASE CONSTANT VOLUME SPECIFIC HEAT CAPACITY 
C                  (BTU/LB-F, REAL*8)
C      XHEAT =     LOCAL INTERNAL HEAT ENERGY CONTENT
C                  (FT-LB/SQ-DAY, REAL*8)
C  OUTPUT:
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  RHOS(IDIM,JDIM,KDIM),XCVS(IDIM,JDIM,KDIM),
     &        XCVL(IDIM,JDIM,KDIM,NPH),PV(IDIM,JDIM,KDIM),
     &        PVOLD(IDIM,JDIM,KDIM),MDEN(IDIM,JDIM,KDIM,NPH),
     &        MDENOLD(IDIM,JDIM,KDIM,NPH),SAT(IDIM,JDIM,KDIM,NPH),
     &        SATOLD(IDIM,JDIM,KDIM,NPH),TEMPR(IDIM,JDIM,KDIM),
     &        XHEAT(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,K,IOFF,JOFF,KOFF,IERR,IPH
      REAL*8 DX,DY,DZ,VOL,XTCPC,PVI,SATI,MDENI
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XUPTMPR: READING BLKOFF!'
         STOP 13
      ENDIF

C  COMPUTE TEMPR
      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               XTCPC = ZERO
               IF(KEYOUT(I,J,K) <= 0) CYCLE
               DX=DXREC(I+IOFF,NBLK)
               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               VOL=DX*DY*DZ
               PVI=PVOLD(I,J,K)+THTFAC*(PV(I,J,K)-PVOLD(I,J,K))
               XTCPC=XTCPC+(VOL-PVI)*RHOS(I,J,K)*XCVS(I,J,K)
               DO IPH=1,NPH
                  SATI=SATOLD(I,J,K,IPH)+THTFAC*(SAT(I,J,K,IPH)
     &                                          -SATOLD(I,J,K,IPH))
                  MDENI=MDENOLD(I,J,K,IPH)+THTFAC*(MDEN(I,J,K,IPH)
     &                                            -MDENOLD(I,J,K,IPH))
                  XTCPC=XTCPC+PVI*MDENI*SATI*XCVL(I,J,K,IPH)
               END DO
               IF(XTCPC == ZERO) THEN
                  STOP 'ERROR IN XUPTMPR, MTEMP IS ZERO!!'
               ENDIF
               TEMPR(I,J,K)=XHEAT(I,J,K)/XTCPC
            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XGETDTEMPRBD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                        KL2,KEYOUT,NBLK,TEMPR,XTDUNK)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C***********************************************************************
C  THIS ROUTINE SETS TEMPERATURE (AFTER IMPLICIT HEAT DIFFUSION SOLVE)
C  INPUT:
C      XTDUNK = HEAT (DIFFUSION) EQUATION SOLUTION (REAL*8)
C               (DEGREES F, REAL*8)
C  OUTPUT:
C      TEMPR(IM1/IP1,J,K) =  CHANGE IN RESERVOIR TEMPERATURE AT OVER- 
C               AND UNDERBURDEN SURFACES, STORED IN GHOST LAYERS 
C               (DEGREES F, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IM1,IP1,IL1,IL2,KL1,KL2,JL1V(KDIM),
     &        JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  XTDUNK(IDIM,JDIM,KDIM),TEMPR(IDIM,JDIM,KDIM)
      LOGICAL TOPEL,BOTEL
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,K
C-----------------------------------------------------------------------

      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               IM1=I-1
               IP1=I+1
               TOPEL=.FALSE.
               BOTEL=.FALSE.
               IF((KEYOUT(I,J,K) > 0 .AND. KEYOUT(IM1,J,K) /= 0 .AND.
     &             KEYOUT(IP1,J,K) /= 0) .OR. KEYOUT(I,J,K) <= 0) THEN
                  CYCLE
               ELSE
                  IF(KEYOUT(I,J,K) > 0 .AND. KEYOUT(IM1,J,K) == 0) 
     &            TOPEL=.TRUE.
                  IF(KEYOUT(I,J,K) > 0 .AND. KEYOUT(IP1,J,K) == 0) 
     &            BOTEL=.TRUE.
               ENDIF

               IF(TOPEL) THEN
                  TEMPR(IM1,J,K)=XTDUNK(I,J,K)-TEMPR(I,J,K)
               ENDIF
               IF(BOTEL) THEN
                  TEMPR(IP1,J,K)=XTDUNK(I,J,K)-TEMPR(I,J,K)
               ENDIF
            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XSETTMPR(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,TEMPR,XTDUNK)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C***********************************************************************
C  THIS ROUTINE SETS TEMPERATURE (AFTER IMPLICIT HEAT DIFFUSION SOLVE)
C  INPUT:
C      XTDUNK =  HEAT (DIFFUSION) EQUATION SOLUTION (REAL*8)
C                (DEGREES F, REAL*8)
C  OUTPUT:
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  XTDUNK(IDIM,JDIM,KDIM),TEMPR(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,K
C-----------------------------------------------------------------------

      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               IF(KEYOUT(I,J,K) <= 0) CYCLE
               TEMPR(I,J,K)=XTDUNK(I,J,K)
            END DO
         END DO
      END DO

      RETURN
      END

C***********************************************************************
      SUBROUTINE XTMPWELL(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                    KEYOUT,NBLK,MLFRC,MLFRC_OLD,TEMPR,XCPL,XHEAT,
     &                    XTCP)
C***********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'control.h'
      INCLUDE 'unitsex.h'
      INCLUDE 'wells.h'
      INCLUDE 'xresprop.h'
      INCLUDE 'xthermal.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xcompwel.h'
      INCLUDE 'xwells.h'
C***********************************************************************
C  THIS ROUTINE SETS RHS FOR THERMAL ADVECTION COMPONENT DUE TO WELLS.
C  INPUT:
C      MLFRC =     COMPONENT MOLE FRACTIONS IN EACH PHASE (REAL*8)
C      MLFRC_OLD = OLD TIME COMPONENT MOLE FRACTIONS IN EACH PHASE 
C                  (REAL*8)
C      TEMPR =     RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      XCPL =      FLUID PHASE ISOBARIC SPECIFIC HEAT CAPACITY OR 
C                  'SPECIFIC ENTHALPY' (BTU/LB-F, REAL*8)
C      XTCP =      RESERVOIR THERMAL CAPACITY (BTU/F, REAL*8)
C  OUTPUT:
C      XHEAT =     LOCAL INTERNAL HEAT ENERGY CONTENT
C                  (FT-LB/SQ-DAY, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK,ISTRM
      REAL*8  MLFRC(IDIM,JDIM,KDIM,NCINPH),XCPL(IDIM,JDIM,KDIM,NPH),
     &        XHEAT(IDIM,JDIM,KDIM),TEMPR(IDIM,JDIM,KDIM),
     &        XTCP(IDIM,JDIM,KDIM)
      REAL*8  MLFRC_OLD(IDIM,JDIM,KDIM,NCINPH)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,J,JST,K,IOFF,JOFF,KOFF,IG,JG,KG,IERR,IW,IC,IPH,L,LC,NE
      REAL*8 HWELL,SUMIC(NC),SUMPH(NPH),PHMOLW(NPH),PHMOLD(NPH),
     &       PHCP(NPH),DWB_FVF,DWB_FVF_CW,WDEN,TSOURCE,DX,DY,DZ,VOL,
     &       QLAYW,SUML,MOLFRAC,MOLWT,COMPCP
C-----------------------------------------------------------------------
      DWB_FVF = WATDEN/WATFVF
      DWB_FVF_CW = DWB_FVF*WATCOMP

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTMPWELL: READING BLKOFF!'
         STOP 13
      ENDIF

C LOOP OVER WELLS TO GET CONTRIBUTION TO HEAT ADVECTION 
      DO IW=1,NUMWEL
         IF(MODWEL(IW) /= MODACT .OR. NWELPRC(IW) /= MYPRC) CYCLE
         IF(IWTYPE(IW) == 0) CYCLE
         NE = NUMELE(IW)
         DO  L = 1,NE
            DO IC=1,NC
               SUMIC(IC)=ZERO
            END DO
            IF (LOCWEL(6,L,IW)==MYPRC .AND. LOCWEL(1,L,IW)==NBLK) THEN
               I = LOCWEL(3,L,IW)-IOFF
               J = LOCWEL(4,L,IW)-JOFF
               K = LOCWEL(5,L,IW)-KOFF
               IF(KEYOUT(I,J,K) /= 1) CYCLE
               DX=DXREC(I+IOFF,NBLK)
               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               VOL=DX*DY*DZ
               IF(IWTYPE(IW) < 0) THEN
                  TSOURCE=TINJ(IW)
               ELSE
                  TSOURCE=TEMPR(I,J,K)
               ENDIF
               HWELL=ZERO
               ISTRM=INJCOMP(IW)
               DO IC=1,NC
                  IF(IWTYPE(IW) < 0.AND.COMPINJ(IC,ISTRM) <= ZERO) CYCLE
                  IF(NSTEP == 1 .AND. ITHSTEP == 1) THEN
                     QLAYTWN(IC,L,IW)=ZERO
                  ENDIF
                  IF(ITHSTEP == 1) THEN
                     QLAYTW(IC,L,IW)=(WELBHP(IW)+WELDEN(IW)
     &                  *(ELEDEP(L,IW)-WDEPTH(IW))-WPRES(L,IW))
     &                     *WELL_COEF(IC,L,IW)
                  ENDIF
                  QLAYW=QLAYTWN(IC,L,IW)+THTFAC*(QLAYTW(IC,L,IW)
     &                 -QLAYTWN(IC,L,IW))
                  IF(IC == 1) THEN
                     HWELL=HWELL+QLAYW*WATCP
                  ELSE
                     HWELL=HWELL+QLAYW*HCCP(IC-1)
                  ENDIF
                  IF(ITHSTEP == NTHSTEP) THEN
                     QLAYTWN(IC,L,IW)=QLAYTW(IC,L,IW)
                  ENDIF
               END DO

               HWELL = HWELL*TSOURCE*THDTIM

               IF(XTHCFLCHK .AND. (DABS(HWELL/TSOURCE) >= 
     &            DABS(XHEAT(I,J,K)/TEMPR(I,J,K)))) THEN
      WRITE(0,*) "IN WELL ",IW," CFL VIOLATED, HWELL TERM=",
     &            DABS(HWELL/TSOURCE)," XHEAT TERM=",
     &            DABS(XHEAT(I,J,K)/TEMPR(I,J,K))
                  XTHCFLERR = .TRUE.
                  THCFLSTEP = DABS(XHEAT(I,J,K)*THDTIM/HWELL)
               ENDIF

               XHEAT(I,J,K)=XHEAT(I,J,K)+HWELL
            ENDIF
         END DO
      END DO

      RETURN
      END

C*********************************************************************
      SUBROUTINE XTHCOND(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                   KEYOUT,NBLK,PV,PVOLD,SAT,SATOLD,TEMPR,XTCOND)
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xresprop.h'
      INCLUDE 'xthermal.h'
C*********************************************************************
C  THIS ROUTINE CALCULATES OVERALL THERMAL CONDUCTIVITY BASED ON A 
C  'LINEAR MIXING' RULE SIMILAR TO THE METHOD IN SIMULATOR ECLIPSE 
C  INPUT:
C      PV =      PORE VOLUME (CU-FT, REAL*8)
C      PVOLD =   OLD TIME PORE VOLUME (CU-FT, REAL*8)
C      SAT =     PHASE SATURATION (REAL*8)
C      SATOLD =  OLD TIME PHASE SATURATION (REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C  OUTPUT:
C      XTCOND =  THERMAL CONDUCTIVITY (BTU/FT-DAY-F, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8 PV(IDIM,JDIM,KDIM),PVOLD(IDIM,JDIM,KDIM),
     &       SAT(IDIM,JDIM,KDIM,NPH),SATOLD(IDIM,JDIM,KDIM,NPH),
     &       TEMPR(IDIM,JDIM,KDIM),XTCOND(IDIM,JDIM,KDIM,3)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,IPH,IDIR,IERR,IOFF,J,JOFF,K,KOFF
      REAL*8 DX,DY,DZ,VOL,PHI,KAPPA(3),KAPPASI,TK,DELTK,DELKAP,BCPRD1,
     &       BCPRD2,BCPRD,PRV,PHSAT
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTHCOND: READING BLKOFF!'
         STOP 13
      ENDIF

      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               IF(KEYOUT(I,J,K) <= 0) CYCLE
               DX=DXREC(I+IOFF,NBLK)
               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               VOL=DX*DY*DZ
               PRV=PVOLD(I,J,K)+THTFAC*(PV(I,J,K)-PVOLD(I,J,K))
               PHI=PRV/VOL
               DELTK=(TEMPR(I,J,K)-TSURF)*CVF2K
               TK=CVF2K*(TEMPR(I,J,K)-32.0D0)+273.15D0
               DO IDIR=1,3
                  KAPPA(IDIR)=ZERO
                  DO IPH=1,NPH
                     PHSAT=SATOLD(I,J,K,IPH)+THTFAC*(SAT(I,J,K,IPH)
     &                    -SATOLD(I,J,K,IPH))
                     KAPPA(IDIR)=KAPPA(IDIR)+PHSAT*PHTCOND(IPH+1,IDIR)
                  END DO
                  KAPPA(IDIR)=PHI*KAPPA(IDIR)+(ONE-PHI)*PHTCOND(1,IDIR)
                  KAPPASI=KAPPA(IDIR)*CV2SI
                  IF(XTPROPVAR) THEN
                     DELKAP=KAPPASI-BMIX
                     BCPRD1=(KAPPASI**(-0.64D0))
                     BCPRD2=KAPPASI*((DMIX*TK)**(EMIX*KAPPASI))+CMIX
                     BCPRD=BCPRD1*BCPRD2
                     XTCOND(I,J,K,IDIR)=KAPPASI-AMIX*DELTK*DELKAP*BCPRD
                     XTCOND(I,J,K,IDIR)=XTCOND(I,J,K,IDIR)*CV2FPD/BTUF
                  ELSE
                     XTCOND(I,J,K,IDIR)=KAPPA(IDIR)
                  ENDIF
               END DO
            END DO
         END DO
      END DO

      RETURN
      END

C*********************************************************************
      SUBROUTINE XTHCONDBD(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                     KL2,KEYOUT,NBLK,PV,PVOLD,SAT,SATOLD,XTCOND)
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xresprop.h'
      INCLUDE 'xthermal.h'
C*********************************************************************
C  THIS ROUTINE CALCULATES OVERALL THERMAL CONDUCTIVITY OF OVER- AND 
C  UNDER-BURDEN BASED ON A 'LINEAR MIXING' RULE SIMILAR TO THE METHOD 
C  IN SIMULATOR ECLIPSE 
C  INPUT:
C      PV =      PORE VOLUME (CU-FT, REAL*8)
C      PVOLD =   OLD TIME PORE VOLUME (CU-FT, REAL*8)
C      SAT =     PHASE SATURATION (REAL*8)
C      SATOLD =  OLD TIME PHASE SATURATION (REAL*8)
C      TEMPR =   RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C  OUTPUT:
C      XTCOND =  THERMAL CONDUCTIVITY (BTU/FT-DAY-F, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8 PV(IDIM,JDIM,KDIM),PVOLD(IDIM,JDIM,KDIM),
     &       SAT(IDIM,JDIM,KDIM,NPH),SATOLD(IDIM,JDIM,KDIM,NPH),
     &       XTCOND(IDIM,JDIM,KDIM,3)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,IM1,IP1,IPH,IERR,IOFF,J,JOFF,K,KOFF,NXL
      REAL*8 DX,DY,DZ,VOL,PHI,KAPPAT,KAPPAB,DELKAP,BCPRD1,BCPRD2,
     &       BCPRD,PRV,PHSAT
      LOGICAL TOPEL,BOTEL
C-----------------------------------------------------------------------

C  GET BLOCK OFFSETS
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XTHCONDBD: READING BLKOFF!'
         STOP 13
      ENDIF

      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               IM1=I-1
               IP1=I+1
               TOPEL=.FALSE.
               BOTEL=.FALSE.
               IF((KEYOUT(I,J,K) > 0 .AND. KEYOUT(IM1,J,K) /= 0 .AND.
     &            KEYOUT(IP1,J,K) /= 0) .OR. KEYOUT(I,J,K) <= 0) THEN
                  CYCLE
               ELSE
                  IF(KEYOUT(I,J,K) > 0 .AND. KEYOUT(IM1,J,K) == 0) 
     &            TOPEL=.TRUE.
                  IF(KEYOUT(I,J,K) > 0 .AND. KEYOUT(IP1,J,K) == 0) 
     &            BOTEL=.TRUE.
               ENDIF
               DX=DXREC(I+IOFF,NBLK)
               DY=DYREC(J+JOFF,NBLK)
               DZ=DZREC(K+KOFF,NBLK)
               VOL=DX*DY*DZ
               PRV=PVOLD(I,J,K)+THTFAC*(PV(I,J,K)-PVOLD(I,J,K))
               PHI=PRV/VOL
               KAPPAT=ZERO
               KAPPAB=ZERO
               DO IPH=1,NPH
                  PHSAT=SATOLD(I,J,K,IPH)+THTFAC*(SAT(I,J,K,IPH)
     &                 -SATOLD(I,J,K,IPH))
                  IF(TOPEL) KAPPAT=KAPPAT+PHSAT*LMDOB(IPH+1)
                  IF(BOTEL) KAPPAB=KAPPAB+PHSAT*LMDUB(IPH+1)
               END DO
               IF(TOPEL) KAPPAT=PHI*KAPPAT+(ONE-PHI)*LMDOB(1)
               IF(BOTEL) KAPPAB=PHI*KAPPAB+(ONE-PHI)*LMDUB(1)
               IF(TOPEL) XTCOND(IM1,J,K,1)=KAPPAT
               IF(BOTEL) XTCOND(IP1,J,K,1)=KAPPAB
            END DO
         END DO
      END DO

      RETURN
      END

C*********************************************************************
      SUBROUTINE XSPHEAT(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
     &                   KEYOUT,NBLK,TEMPR,MLFRC,MLFRC_OLD,XCPL,XCVL,
     &                   XCVS)
C*********************************************************************
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'layout.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xresprop.h'
      INCLUDE 'xthermal.h'
C*********************************************************************
C  THIS ROUTINE CALCULATES PHASE SPECIFIC HEAT CAPACITIES BASED ON A 
C  POLYNOMIAL (IN T-TREF) RULE SIMILAR TO THE METHOD IN STARS SIMULATOR.
C  INPUT:
C      TEMPR =     RESERVOIR TEMPERATURE (DEGREES F, REAL*8)
C      MLFRC =     COMPONENT MOLE FRACTIONS IN EACH PHASE (REAL*8)
C      MLFRC_OLD = OLD TIME COMPONENT MOLE FRACTIONS IN EACH PHASE 
C                  (REAL*8)
C  OUTPUT:
C      XCPL =    FLUID PHASE ISOBARIC SPECIFIC HEAT CAPACITY 
C                (BTU/LB-F, REAL*8)
C      XCVL =    FLUID PHASE ISOCHORIC SPECIFIC HEAT CAPACITY 
C                (BTU/LB-F, REAL*8)
C      XCVS =    ROCK ISOCHORIC SPECIFIC HEAT CAPACITY 
C                (BTU/LB-F, REAL*8)
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,JL1V(KDIM),JL2V(KDIM),
     &        KEYOUT(IDIM,JDIM,KDIM),NBLK
      REAL*8  MLFRC(IDIM,JDIM,KDIM,NCINPH),XCPL(IDIM,JDIM,KDIM,NPH),
     &        XCVL(IDIM,JDIM,KDIM,NPH),XCVS(IDIM,JDIM,KDIM),
     &        TEMPR(IDIM,JDIM,KDIM)
      REAL*8  MLFRC_OLD(IDIM,JDIM,KDIM,NCINPH)
C-----------------------------------------------------------------------
C     Local variables
      INTEGER I,IC,IHC,IPH,IOFF,IERR,J,JOFF,K,KOFF,LC,OIL,GAS
      REAL*8  DELT_BTUF,PARTIALCV,PARTIALCP,HCCPL,MOLFRAC
      PARAMETER(OIL=2,GAS=3)
C-----------------------------------------------------------------------
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR > 0) THEN
         WRITE(0,*) 'ERROR IN XSPHEAT: READING BLKOFF!'
         STOP 13
      ENDIF

      DO K=KL1,KL2
         DO J=JL1V(K),JL2V(K)
            DO I=IL1,IL2
               IF(KEYOUT(I,J,K) <= 0) CYCLE
               DELT_BTUF=(TEMPR(I,J,K)-TSURF)
               XCVS(I,J,K)=ROCKCV
               IF(XTPROPVAR) XCVS(I,J,K)=XCVS(I,J,K)+CVRCKGRD*DELT_BTUF
               DO IPH=1,NPH
                  XCVL(I,J,K,IPH)=ZERO
                  XCPL(I,J,K,IPH)=ZERO
                  PARTIALCV=ZERO
                  PARTIALCP=ZERO
                  IF(IPH == 1) THEN
                     XCVL(I,J,K,IPH)=(WATCV/WATMOLW)
                     XCPL(I,J,K,IPH)=(WATCP/WATMOLW)
                     IF(XTPROPVAR) THEN
                        XCVL(I,J,K,IPH)=XCVL(I,J,K,IPH)
     &                                 +CVWATGRD*DELT_BTUF
                        XCPL(I,J,K,IPH)=XCPL(I,J,K,IPH)
     &                                 +CPWATGRD*DELT_BTUF
                     ENDIF
                     CYCLE
                  ENDIF
                  DO IC=1,NC
                     LC=ICINPH(IC,IPH)
                     IF(LC == 0) CYCLE
                     IF(IC > 1) THEN
                        IHC=IC-1
                     ELSE
                        STOP 'ERROR IN XSPHEAT W.R.T. INDEX IC!!'
                     ENDIF
                     MOLFRAC=MLFRC_OLD(I,J,K,LC)+THTFAC*(MLFRC(I,J,K,LC)
     &                      -MLFRC_OLD(I,J,K,LC))
                        PARTIALCV=(HCCV(IHC)/WMOL(IHC))*MOLFRAC
                        PARTIALCP=(HCCP(IHC)/WMOL(IHC))*MOLFRAC
                     XCVL(I,J,K,IPH)=XCVL(I,J,K,IPH)+PARTIALCV
                     XCPL(I,J,K,IPH)=XCPL(I,J,K,IPH)+PARTIALCP
                  END DO
                  IF(IPH == OIL .AND. XTPROPVAR) THEN
                     XCVL(I,J,K,IPH)=XCVL(I,J,K,IPH)
     &                              +CVOILGRD*DELT_BTUF
                     XCPL(I,J,K,IPH)=XCPL(I,J,K,IPH)
     &                              +CPOILGRD*DELT_BTUF
                  ELSEIF(IPH == GAS .AND. XTPROPVAR) THEN
                     XCVL(I,J,K,IPH)=XCVL(I,J,K,IPH)
     &                              +CVGASGRD*DELT_BTUF
                     XCPL(I,J,K,IPH)=XCPL(I,J,K,IPH)
     &                              +CPGASGRD*DELT_BTUF
                  ENDIF
               END DO
            END DO
         END DO
      END DO

      RETURN
      END

C*********************************************************************
      SUBROUTINE XTLINSOL (ITLN,NERR)
C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xarydat.h'
      INCLUDE 'xthermal.h'
C***********************************************************************
C  THIS ROUTINE SETS SOLVES LINEAR SYSTEM FOR RESERVOIR TEMPERATURE.
C  NOTE: CURRENTLY ONLY GMRES AND BCGS IS ACTIVATED FOR TEMPERATURE 
C  SOLVE. IN THE FUTURE, ROUTINES IN SOLVE/MULGRD, SOLVE/PCG MAY HAVE 
C  TO BE SUITABLY EDITED TO ACTIVATE TEMPERATURE STIFFNESS MATRIX IN 
C  ORDER TO USE THESE LINEAR SOLVERS.
C  INPUT/OUTPUT:
C     ITLN  =   NUMBER OF LINEAR ITERATIONS TO CONVERGENCE.
C     NERR  =   ERROR TAG.
C-----------------------------------------------------------------------

      EXTERNAL TICAMG,TICAMAT
      INTEGER ITLN,NERR

      ITLN = 0

$GMRES       IF(ITHLINSOL == 1) CALL TICAMG(N_XTCOF,N_XTDUNK,N_XTRESID,1,
$GMRES     &                              ITLN,NERR)
$TICAMA      IF(ITHLINSOL == 2) CALL TICAMAT(N_XTCOF,N_XTDUNK,N_XTRESID,1,
$TICAMA     &                                ITLN,NERR)
$PCG         IF(ITHLINSOL == 3) THEN 
$PCG            STOP 'ERROR: PCG FOR THERMAL CONDUCTION NOT TESTED!'
$PCG         ENDIF

      RETURN
      END


C***********************************************************************
      REAL*8 FUNCTION SGNT(A,B)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C***********************************************************************
C  THIS FUNCTION RETURNS SGN(A)+SGN(B) (USED IN SUPER-BEE FLUX LIMITER)
C  INPUT:
C     A,B  (REAL*8)
C  OUTPUT:
C     SGNT
C-----------------------------------------------------------------------
      REAL*8 A,B,S1,S2
C-----------------------------------------------------------------------

      IF(A.GT.ZERO) THEN
        S1 = ONE
      ELSEIF(A.LT.ZERO) THEN
        S1 = -ONE
      ELSE
        S1 = ZERO
      ENDIF

      IF(B.GT.ZERO) THEN
        S2 = ONE
      ELSEIF(B.LT.ZERO) THEN
        S2 = -ONE
      ELSE
        S2 = ZERO
      ENDIF

      SGNT = S1+S2

      RETURN
      END


C***********************************************************************
      REAL*8 FUNCTION HRMNCMEAN(A,B)
C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
C***********************************************************************
C  THIS FUNCTION RETURNS HARMONIC MEAN OF A AND B
C  INPUT:
C     A,B  (REAL*8)
C  OUTPUT:
C     HRMNCMEAN
C-----------------------------------------------------------------------
      REAL*8 A,B,INV1,INV2
C-----------------------------------------------------------------------

      IF(A*B > ZERO) THEN
         INV1 = ONE/A
         INV2 = ONE/B
         HRMNCMEAN = TWO/(INV1+INV2)
      ELSE
         HRMNCMEAN = ZERO
      ENDIF

      RETURN
      END


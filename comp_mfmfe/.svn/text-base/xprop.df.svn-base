C  XPROP.F - EVALUATE FLOW TERMS MOB, PC, AND MOBPROD

C  ROUTINES IN THIS MODULE:

C  SUBROUTINE XPROP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                   KEYOUT,NBLK,MOB,PMD)
C  SUBROUTINE XRELPERM1(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                       KEYOUT,NBLK,KROCK,,MOB,SAT,PRES)
C  SUBROUTINE XHYSRLPRM1(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,KL2,
C                        KEYOUT,NBLK,KROCK,SAT,SWMIN,SGT,MOB,DMOB,PC,
C                        DPC)
C  SUBROUTINE XSAT_ERROR(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                        KL2,KEYOUT,NBLK,ERRSAT)
C  SUBROUTINE XSAT_SUMERR(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                         KL2,KEYOUT,NBLK,ERRSAT)
C  SUBROUTINE XPRES (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                    KL1,KL2,KEYOUT,NBLK,PRES,DELP)
C  SUBROUTINE XMFRAC_ALL (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                         KL1,KL2,KEYOUT,NBLK,PMD,MOLFRAC)
C  SUBROUTINE XPHMDENS (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                       KL1,KL2,KEYOUT,NBLK,PMD,PHDEN,SAT,DDCOF)
C  SUBROUTINE XPHDENS (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C                      KL1,KL2,KEYOUT,NBLK,PMD,PHDEN)
C  SUBROUTINE XDDINV(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
C          KL1,KL2,KEYOUT,NBLK,XC,YC,ZC,XDMAT,DDINV,MPFAQU)
C  SUBROUTINE XVELCOMP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
C                      KL2,KEYOUT,NBLK,TCOFX,TCOFY,TCOFZ,DEPTH,PRES,
C                      PC,MDEN,MOB,XVEL)
C  SUBROUTINE XVELCOMP2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
C                       JL2V,KL1,KL2,KEYOUT,NBLK,PRES,PC,
C                       VOLPROP,VOLDIM,FACEPROP,FACEDIM,
C                       KEYOUTCR,MOBPROD,UPMOBPROD,MOB,
C                       UPMOB,AINVF,TRAN,XVEL)

C  CODE HISTORY:

C  RICK DEAN         6/26/01   INITIAL VERSION
C  SUNIL G. THOMAS   9/01/07   MOLE FRACTION, MOLAR AND MASS DENSITY,
C                              HYSTERESIS
C  GURPREET SINGH    08/14/14  DIFFUSION-DISPERSION FOR MFMFE

C*********************************************************************
      SUBROUTINE XPROP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                 KL2,KEYOUT,NBLK,MOB,PMD,MOBPROD)
C*********************************************************************

C  ROUTINE SETS UP FLOW COEFFICIENTS. THIS IS A WORK ROUTINE.

C  INPUT:
C     PMD(I,J,K,L) = MASS FRACTION X MOLAR DENSITY (REAL*8)
C     MOB(I,J,K,IPH) = MOBILITY OF PHASE IPH (REAL*8)

C  OUTPUT:
C     MOBPROD(I,J,K,L) = FLOW COEFFICIENT (REAL*8)
C                        MASS FRACTION X MOLAR DENSITY X MOBILITY

C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 MOB(IDIM,JDIM,KDIM,NPH),PMD(IDIM,JDIM,KDIM,NCINPH),
     &       MOBPROD(IDIM,JDIM,KDIM,NCINPH)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,L,IPH,IC

      DO IPH = 1,NPH
      DO IC = 1,NC
         L = ICINPH(IC,IPH)
         IF(L == 0) CYCLE
         DO K = KL1,KL2
            DO  J = JL1V(K),JL2V(K)
               DO  I = IL1,IL2
                  IF(KEYOUT(I,J,K) /= 1) CYCLE
                  MOBPROD(I,J,K,L) = MOB(I,J,K,IPH)*PMD(I,J,K,L)
               END DO
            END DO
         END DO
      END DO
      END DO
      END

C*********************************************************************
      SUBROUTINE XRELPERM1(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                     KL2,KEYOUT,NBLK,KROCK,MOB,SAT,PC,DPC,DMOB)
C*********************************************************************

C  ROUTINE EVALUATES MOBILITIES. THIS IS A WORK ROUTINE OR IS CALLED
C  FROM A WORK ROUTINE.
C  THIS ROUTINE ASSUMES:
C                         PHASE 1 = WATER
C                         PHASE 2 = LIQUID
C                         PHASE 3 = VAPOR

C  INPUT:
C     KROCK(I,J,K) = ROCK CURVE (INTEGER)
C     SAT(I,J,K,IPH) = SATURATION FOR PHASE IPH (REAL*8)

C  INPUT/OUTPUT:
C     MOB(I,J,K,IPH) = MOBILITY FOR PHASE IPH (REAL*8)
C                      ASSUMES MOB ALREADY CONTAINS 1/VISCOSITY TERM
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE OF PHASE IPH (REAL*8)
C     DMOB(I,J,K,*) = MOBILITY DERIVATIVE (REAL*4)
C     DPC(I,J,K,*) = CAPILLARY PRESSURE DERIVATIVE (REAL*4)


C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'rock.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER KROCK(IDIM,JDIM,KDIM)
      REAL*8 MOB(IDIM,JDIM,KDIM,NPH),SAT(IDIM,JDIM,KDIM,NPH),
     &       PC(IDIM,JDIM,KDIM,NPH)
      REAL*4 DPC(IDIM,JDIM,KDIM,2),DMOB(IDIM,JDIM,KDIM,4)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,KR
      REAL*8 SW,SG,PCOW,PCGO,DPCOW,DPCGO,RELW,RELO,RELG,DKWSW,
     &       DKOSW,DKOSG,DKGSG,P
C-----------------------------------------------------------------------
C     THREE-PHASE
C-----------------------------------------------------------------------
      IF(NPH == 3) THEN
         IF(IREFPRES == 1) THEN
            DO K = KL1,KL2
               DO  J = JL1V(K),JL2V(K)
                  DO  I = IL1,IL2
                     IF (KEYOUT(I,J,K) /= 1) CYCLE
                     KR = KROCK(I,J,K)
                     SW = SAT(I,J,K,1)
                     SG = SAT(I,J,K,3)

                     CALL LOOKUP(NPCOW(KR),SW,PCOW,DPCOW)
                     CALL LOOKUP(NPCGO(KR),ONE-SG,PCGO,DPCGO)
                     PC(I,J,K,1) = ZERO
                     PC(I,J,K,2) = PCOW
                     PC(I,J,K,3) = PCGO + PCOW
                     IF(ABS(PCOW) <= TEN_M10) DPCOW = ZERO
                     IF(ABS(PCGO) <= TEN_M10) DPCGO = ZERO
                     DPC(I,J,K,1) = DPCOW
                     DPC(I,J,K,2) = DPCGO

                     CALL RELPERM3(KR,SW,SG,RELW,RELG,RELO,DKWSW,
     &                             DKOSW,DKOSG,DKGSG)
                     IF(RELW <= TEN_M10) DKWSW = ZERO
                     IF(RELO <= TEN_M10) THEN
                        DKOSW = ZERO
                        DKOSG = ZERO
                     ENDIF
                     IF(RELG <= TEN_M10) DKGSG = ZERO
                     DMOB(I,J,K,1) = DKWSW * MOB(I,J,K,1)
                     DMOB(I,J,K,2) = DKOSW * MOB(I,J,K,2)
                     DMOB(I,J,K,3) = DKOSG * MOB(I,J,K,2)
                     DMOB(I,J,K,4) = DKGSG * MOB(I,J,K,3)
                     MOB(I,J,K,1) = RELW * MOB(I,J,K,1)
                     MOB(I,J,K,2) = RELO * MOB(I,J,K,2)
                     MOB(I,J,K,3) = RELG * MOB(I,J,K,3)
                  END DO
               END DO
            END DO
         ELSEIF(IREFPRES == 2) THEN
            DO K = KL1,KL2
               DO  J = JL1V(K),JL2V(K)
                  DO  I = IL1,IL2
                     IF (KEYOUT(I,J,K) /= 1) CYCLE
                     KR = KROCK(I,J,K)
                     SW = SAT(I,J,K,1)
                     SG = SAT(I,J,K,3)

                     CALL LOOKUP(NPCOW(KR),SW,PCOW,DPCOW)
                     CALL LOOKUP(NPCGO(KR),ONE-SG,PCGO,DPCGO)
                     IF(ABS(PCOW) <= TEN_M10) DPCOW = ZERO
                     IF(ABS(PCGO) <= TEN_M10) DPCGO = ZERO
                     PC(I,J,K,1) = -PCOW
                     PC(I,J,K,2) = ZERO
                     PC(I,J,K,3) = PCGO
                     DPC(I,J,K,1) = DPCOW
                     DPC(I,J,K,2) = DPCGO
                     CALL RELPERM3(KR,SW,SG,RELW,RELG,RELO,DKWSW,
     &                             DKOSW,DKOSG,DKGSG)
                     IF (RELW <= TEN_M10) DKWSW = ZERO
                     IF (RELO <= TEN_M10) THEN
                        DKOSW = ZERO
                        DKOSG = ZERO
                     ENDIF
                     IF(RELG <= TEN_M10) DKGSG = ZERO
                     DMOB(I,J,K,1) = DKWSW * MOB(I,J,K,1)
                     DMOB(I,J,K,2) = DKOSW * MOB(I,J,K,2)
                     DMOB(I,J,K,3) = DKOSG * MOB(I,J,K,2)
                     DMOB(I,J,K,4) = DKGSG * MOB(I,J,K,3)
                     MOB(I,J,K,1) = RELW * MOB(I,J,K,1)
                     MOB(I,J,K,2) = RELO * MOB(I,J,K,2)
                     MOB(I,J,K,3) = RELG * MOB(I,J,K,3)

                  END DO
               END DO
            END DO
         ELSE
            DO K = KL1,KL2
               DO  J = JL1V(K),JL2V(K)
                  DO  I = IL1,IL2
                     IF (KEYOUT(I,J,K) /= 1) CYCLE
                     KR = KROCK(I,J,K)
                     SW = SAT(I,J,K,1)
                     SG = SAT(I,J,K,3)

                     CALL LOOKUP(NPCOW(KR),SW,PCOW,DPCOW)
                     CALL LOOKUP(NPCGO(KR),ONE-SG,PCGO,DPCGO)
                     IF(ABS(PCOW) <= TEN_M10) DPCOW = ZERO
                     IF(ABS(PCGO) <= TEN_M10) DPCGO = ZERO
                     PC(I,J,K,1) = -PCOW-PCGO
                     PC(I,J,K,2) = -PCGO
                     PC(I,J,K,3) = ZERO
                     DPC(I,J,K,1) = DPCOW
                     DPC(I,J,K,2) = DPCGO

                     CALL RELPERM3(KR,SW,SG,RELW,RELG,RELO,DKWSW,
     &                             DKOSW,DKOSG,DKGSG)
                     IF(RELW <= TEN_M10) DKWSW = ZERO
                     IF(RELO <= TEN_M10) THEN
                        DKOSW = ZERO
                        DKOSG = ZERO
                     ENDIF
                     IF(RELG <= TEN_M10) DKGSG = ZERO
                     DMOB(I,J,K,1) = DKWSW * MOB(I,J,K,1)
                     DMOB(I,J,K,2) = DKOSW * MOB(I,J,K,2)
                     DMOB(I,J,K,3) = DKOSG * MOB(I,J,K,2)
                     DMOB(I,J,K,4) = DKGSG * MOB(I,J,K,3)
                     MOB(I,J,K,1) = RELW * MOB(I,J,K,1)
                     MOB(I,J,K,2) = RELO * MOB(I,J,K,2)
                     MOB(I,J,K,3) = RELG * MOB(I,J,K,3)
                  END DO
               END DO
            END DO
         ENDIF
C-----------------------------------------------------------------------
C     TWO-PHASE
C-----------------------------------------------------------------------
      ELSEIF(NPH == 2) THEN
         IF(IREFPRES == 1) THEN
            DO K = KL1,KL2
               DO  J = JL1V(K),JL2V(K)
                  DO  I = IL1,IL2
                     IF (KEYOUT(I,J,K) /= 1) CYCLE
                     KR = KROCK(I,J,K)
                     SW = SAT(I,J,K,1)
                     SG = ZERO

                     CALL LOOKUP(NPCOW(KR),SW,PCOW,DPCOW)
                     IF(ABS(PCOW) <= TEN_M10) DPCOW = ZERO
                     PC(I,J,K,1) = ZERO
                     PC(I,J,K,2) = PCOW
                     DPC(I,J,K,1) = DPCOW

                     CALL RELPERM3(KR,SW,SG,RELW,RELG,RELO,DKWSW,
     &                             DKOSW,DKOSG,DKGSG)
                     IF(RELW <= TEN_M10) DKWSW = ZERO
                     IF(RELO <= TEN_M10) DKOSW = ZERO
                     DMOB(I,J,K,1) = DKWSW * MOB(I,J,K,1)
                     DMOB(I,J,K,2) = DKOSW * MOB(I,J,K,2)
                     MOB(I,J,K,1) = RELW * MOB(I,J,K,1)
                     MOB(I,J,K,2) = RELO * MOB(I,J,K,2)
                  END DO
               END DO
            END DO
         ELSE
            DO K = KL1,KL2
               DO  J = JL1V(K),JL2V(K)
                  DO  I = IL1,IL2
                     IF (KEYOUT(I,J,K) /= 1) CYCLE
                     KR = KROCK(I,J,K)
                     SW = SAT(I,J,K,1)
                     SG = ZERO

                     CALL LOOKUP(NPCOW(KR),SW,PCOW,DPCOW)
                     IF(ABS(PCOW) <= TEN_M10) DPCOW = ZERO
                     PC(I,J,K,1) = -PCOW
                     PC(I,J,K,2) = ZERO
                     DPC(I,J,K,1) = DPCOW

                     CALL RELPERM3(KR,SW,SG,RELW,RELG,RELO,DKWSW,
     &                             DKOSW,DKOSG,DKGSG)
                     IF(RELW <= TEN_M10) DKWSW = ZERO
                     IF(RELO <= TEN_M10) DKOSW = ZERO
                     DMOB(I,J,K,1) = DKWSW * MOB(I,J,K,1)
                     DMOB(I,J,K,2) = DKOSW * MOB(I,J,K,2)
                     MOB(I,J,K,1) = RELW * MOB(I,J,K,1)
                     MOB(I,J,K,2) = RELO * MOB(I,J,K,2)
                  END DO
               END DO
            END DO
         ENDIF
C-----------------------------------------------------------------------
C     SINGLE-PHASE
C-----------------------------------------------------------------------
      ELSEIF(NPH == 1) THEN
         DO K = KL1,KL2
            DO  J = JL1V(K),JL2V(K)
               DO  I = IL1,IL2
                  PC(I,J,K,1) = ZERO
               END DO
            END DO
         END DO
      ENDIF
      END

C*********************************************************************
      SUBROUTINE XHYSRLPRM1(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                      KL2,KEYOUT,NBLK,KROCK,SAT,SWMIN,SGT,MOB,
     &                      DMOB,PC,DPC)
C*********************************************************************

C  ROUTINE EVALUATES MOBILITIES. THIS IS A WORK ROUTINE OR IS CALLED
C  FROM A WORK ROUTINE.
C  THIS ROUTINE ASSUMES:
C                         PHASE 1 = WATER
C                         PHASE 2 = LIQUID
C                         PHASE 3 = VAPOR

C  INPUT:
C     KROCK(I,J,K) = ROCK CURVE (INTEGER)
C     SAT(I,J,K,IPH) = SATURATION FOR PHASE IPH (REAL*8)

C  INPUT/OUTPUT:
C     SWMIN(I,J,K) = EFFECTIVE REVERSAL WETTING PHASE SATURATION
C                    (REAL*8)
C     SGT(I,J,K) = EFFECTIVE TRAPPED NON-WETTING PHASE SATURATION
C                  (REAL*8)
C     MOB(I,J,K,IPH) = MOBILITY FOR PHASE IPH (REAL*8)
C                      ASSUMES MOB ALREADY CONTAINS 1/VISCOSITY TERM
C     PC(I,J,K,IPH) = CAPILLARY PRESSURE OF PHASE IPH (REAL*8)
C     DMOB(I,J,K,*) = MOBILITY DERIVATIVE (REAL*4)
C     DPC(I,J,K,*) = CAPILLARY PRESSURE DERIVATIVE (REAL*4)

C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'rock.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      INTEGER KROCK(IDIM,JDIM,KDIM)
      REAL*8 MOB(IDIM,JDIM,KDIM,NPH),SAT(IDIM,JDIM,KDIM,NPH),
     &       SWMIN(IDIM,JDIM,KDIM),SGT(IDIM,JDIM,KDIM),
     &       PC(IDIM,JDIM,KDIM,NPH)
      REAL*4 DPC(IDIM,JDIM,KDIM,2),DMOB(IDIM,JDIM,KDIM,4)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,KR
      REAL*8 SW,SNW,PCNW,DPCNW,DPCOW,RELW,RELN,DKWSW,DKNSW,WKSP,RTERM,
     &       SGTRAP,SWNORM,SWBAR,STNORM

      DO K = KL1,KL2
         DO  J = JL1V(K),JL2V(K)
            DO  I = IL1,IL2
               IF (KEYOUT(I,J,K) /= 1) CYCLE
               KR = KROCK(I,J,K)

               IF (AQPHSWTCH) THEN
                  SNW = SAT(I,J,K,3)
                  SW = SAT(I,J,K,2)
                  SWNORM = (SAT(I,J,K,2)-SORES(KR))
     &                   / (ONE-SORES(KR))
               ELSE
                  SNW = SAT(I,J,K,2)
                  SW = SAT(I,J,K,1)
                  SWNORM = (SAT(I,J,K,1)-SWRES(KR))
     &                   / (ONE-SWRES(KR))
               ENDIF
               SWNORM = MAX(ZERO,SWNORM)
               SWNORM = MIN(ONE,SWNORM)
               SGT(I,J,K) = ZERO
               IF (NSTEP <= 1) GOTO 10
               IF (.NOT.HYSTERESIS) THEN
                  IF (SNW >= TEN_M6) THEN
                     IF (AQPHSWTCH) THEN
                        SGT(I,J,K) = SGRES(KR)/(ONE-SORES(KR))
                     ELSE
                        SGT(I,J,K) = SORES(KR)/(ONE-SWRES(KR))
                     ENDIF
                  ENDIF
                  GOTO 10
               ENDIF

               IF (SNW > TEN_M6) THEN
                  IF (SGRES(KR) > TEN_M6) THEN
                     IF (AQPHSWTCH) THEN
                        WKSP = SGRES(KR)/(ONE-SORES(KR))
                     ELSE
                        WKSP = SORES(KR)/(ONE-SWRES(KR))
                     ENDIF
                     RTERM = ONE/WKSP-ONE
                  ENDIF
C                 MOVING ALONG DRAINAGE
                  IF (SWNORM <= SWMIN(I,J,K)) THEN
C                    RESET HISTORICAL MIN
                     SWMIN(I,J,K) = SWNORM
                     SGTRAP = ZERO
C                 MOVING ALONG IMBIBITION
                  ELSE
                     SGTRAP = (ONE-SWMIN(I,J,K))
     &                  / (ONE+RTERM*(ONE-SWMIN(I,J,K)))
                  ENDIF
               ELSE
                  SWMIN(I,J,K) = SWNORM
                  SGTRAP = ZERO
               ENDIF

C              DRAINAGE
               IF (SWNORM.LE.SWMIN(I,J,K)) THEN
                  SGT(I,J,K) = ZERO
C              IMBIBITION (LENHARD INTERPOLATION METHOD)
               ELSE
                  IF (SGTRAP+SWMIN(I,J,K) >= ONE) THEN
                     SGT(I,J,K) = ZERO
                  ELSE
                     SGT(I,J,K) = SGTRAP
     &                   * (SWNORM-SWMIN(I,J,K))
     &                   / (ONE-SGTRAP-SWMIN(I,J,K))
                     SGT(I,J,K) = MAX(ZERO,SGT(I,J,K))
                  ENDIF
               ENDIF

  10           CONTINUE

C              COMPUTE APPARENT WETTING PHASE (WATER) SATURATION
               SWBAR = SWNORM+SGT(I,J,K)
               SWBAR = MIN(ONE,SWBAR)

C              COMPUTE WETTING PHASE (WATER) RELATIVE PERMEABILITY
C              USING BURDINE'S EQUATION
               RELW = SWNORM**((TWO+THREE*RPLMDA(KR))/RPLMDA(KR))
               IF (SW >= ONE) GOTO 20

               IF (AQPHSWTCH) THEN
                  DKWSW = ((TWO+THREE*RPLMDA(KR))/RPLMDA(KR))
     &                 * (SWNORM**((TWO+TWO/RPLMDA(KR))))
     &                 / (ONE-SORES(KR))
                  DMOB(I,J,K,1) = ZERO
                  DMOB(I,J,K,2) = DKWSW * MOB(I,J,K,2)
                  MOB(I,J,K,1) = ZERO
                  MOB(I,J,K,2) = RELW * MOB(I,J,K,2)
               ELSE
                  DKWSW = ((TWO+THREE*RPLMDA(KR))/RPLMDA(KR))
     &                  * (SWNORM**((TWO+TWO/RPLMDA(KR))))
     &                  / (ONE-SWRES(KR))
                  DMOB(I,J,K,1) = DKWSW * MOB(I,J,K,1)
                  MOB(I,J,K,1) = RELW * MOB(I,J,K,1)
               ENDIF

   20          CONTINUE
C              COMPUTE NON-WETTING PHASE (OIL/GAS) RELATIVE PERMEABILITY
C              AND CAPILLARY PRESSURE (IF PRESENT)
               IF (SNW > TEN_M6) THEN

                  IF (SWBAR > TEN_M8) THEN
                     PCNW = ENTRYP(KR)*(SWBAR**(-ONE/RPLMDA(KR)))
                  ELSE
                     PCNW = ZERO
                     DPCNW = ZERO
                  ENDIF
                  IF (AQPHSWTCH) THEN
                     PC(I,J,K,1) = ZERO
                     DPC(I,J,K,1) = ZERO
                     DPCNW = ENTRYP(KR)*(-ONE/RPLMDA(KR))
     &                     * (SWBAR**(-ONE-ONE/RPLMDA(KR)))
     &                     / (ONE-SORES(KR))
                     IF (DABS(PCNW) <= TEN_M10) DPCNW = ZERO
                     IF ((IREFPRES==1).OR.(IREFPRES==2)) THEN
                        PC(I,J,K,2) = ZERO
                        PC(I,J,K,3) = PCNW
                     ELSE
                        PC(I,J,K,2) = -PCNW
                        PC(I,J,K,3) = ZERO
                     ENDIF
                     DPC(I,J,K,2) = DPCNW
                     STNORM = SWNORM+SNW/(ONE-SORES(KR))
                  ELSE
                     DPCNW = ENTRYP(KR)*(-ONE/RPLMDA(KR))
     &                     * (SWBAR**(-ONE-ONE/RPLMDA(KR)))
     &                     / (ONE-SWRES(KR))
                     IF (DABS(PCNW) <= TEN_M10) DPCNW = ZERO
                     IF (IREFPRES==1) THEN
                        PC(I,J,K,1) = ZERO
                        PC(I,J,K,2) = PCNW
                     ELSE
                        PC(I,J,K,1) = -PCNW
                        PC(I,J,K,2) = ZERO
                     ENDIF
                     DPC(I,J,K,1) = DPCNW
                     STNORM = SWNORM+SNW/(ONE-SWRES(KR))
                  ENDIF
                  STNORM = MIN(ONE,STNORM)
                  IF (STNORM <= SWBAR) THEN
                     RELN = ZERO
                     DKNSW = ZERO
                  ELSE
                     RELN = KRNW0(KR)*((ONE-SWBAR)**TWO)
     &                    * (ONE-(SWBAR**(ONE+TWO/RPLMDA(KR))))
                     IF (AQPHSWTCH) THEN
                        DKNSW = KRNW0(KR)*(TWO*(ONE-SWBAR)
     &                        * (ONE-(SWBAR**(ONE+TWO/RPLMDA(KR))))
     &                        + ((ONE-SWBAR)**TWO)*(-ONE-TWO/RPLMDA(KR))
     &                        * (SWBAR**(TWO/RPLMDA(KR))))
     &                        / (ONE-SORES(KR))
                        IF (RELN <= TEN_M10) DKNSW = ZERO
                        DMOB(I,J,K,3) = DKNSW*MOB(I,J,K,2)
                        DMOB(I,J,K,4) = DKNSW*MOB(I,J,K,3)
                        MOB(I,J,K,3) = RELN*MOB(I,J,K,3)
                     ELSE
                        DKNSW = KRNW0(KR)*(TWO*(ONE-SWBAR)
     &                        * (ONE-(SWBAR**(ONE+TWO/RPLMDA(KR))))
     &                        + ((ONE-SWBAR)**TWO)*(-ONE-TWO/RPLMDA(KR))
     &                        * (SWBAR**(TWO/RPLMDA(KR))))
     &                        / (ONE-SWRES(KR))
                        IF (RELN <= TEN_M10) DKNSW = ZERO
                        DMOB(I,J,K,2) = DKNSW*MOB(I,J,K,2)
                        MOB(I,J,K,2) = RELN*MOB(I,J,K,2)
                     ENDIF
                  ENDIF

C              CASE WHEN ONLY WETTING (AQUEOUS) PHASE ACTUALLY EXISTS
               ELSE

                  RELN = ZERO
                  DKNSW = ZERO
                  PCNW = ZERO
                  DPCNW = ZERO
                  IF (AQPHSWTCH) THEN
                     MOB(I,J,K,3) = ZERO
                     DMOB(I,J,K,3) = ZERO
                     DMOB(I,J,K,4) = ZERO
                     PC(I,J,K,1) = ZERO
                     PC(I,J,K,1) = ZERO
                     PC(I,J,K,2) = ZERO
                     PC(I,J,K,3) = ZERO
                     DPC(I,J,K,1) = ZERO
                     DPC(I,J,K,2) = ZERO
                  ELSE
                     MOB(I,J,K,2) = ZERO
                     DMOB(I,J,K,2) = ZERO
                     PC(I,J,K,1) = ZERO
                     PC(I,J,K,2) = ZERO
                     DPC(I,J,K,1) = ZERO
                  ENDIF

               ENDIF

C              RE-CHECK FOR SINGLE PHASE CELLS AGAIN
               IF (SW >= ONE) THEN
                  RELW = ONE
                  RELN = ZERO
                  PCNW = ENTRYP(KR)
                  IF (AQPHSWTCH) THEN
                     DKWSW = ((TWO+THREE*RPLMDA(KR))/RPLMDA(KR))
     &                     / (ONE-SORES(KR))
                     DMOB(I,J,K,1) = ZERO
                     DMOB(I,J,K,2) = DKWSW*MOB(I,J,K,2)
                     MOB(I,J,K,1) = ZERO
                     MOB(I,J,K,2) = RELW*MOB(I,J,K,2)
                     DKNSW = ZERO
                     DMOB(I,J,K,3) = ZERO
                     DMOB(I,J,K,4) = ZERO
                     MOB(I,J,K,3) = ZERO
                     DPCNW = ENTRYP(KR)*(-ONE/RPLMDA(KR))
     &                     / (ONE-SORES(KR))
                     PC(I,J,K,1) = ZERO
                     DPC(I,J,K,1) = ZERO
                     DPC(I,J,K,2) = DPCNW
                     IF ((IREFPRES==1).OR.(IREFPRES==2)) THEN
                        PC(I,J,K,2) = ZERO
                        PC(I,J,K,3) = PCNW
                     ELSE
                        PC(I,J,K,2) = -PCNW
                        PC(I,J,K,3) = ZERO
                     ENDIF
                  ELSE
                     MOB(I,J,K,1) = RELW*MOB(I,J,K,1)
                     DKWSW = ((TWO+THREE*RPLMDA(KR))/RPLMDA(KR))
     &                     / (ONE-SWRES(KR))
                     DMOB(I,J,K,1) = DKWSW*MOB(I,J,K,1)
                     DKNSW = ZERO
                     MOB(I,J,K,2) = ZERO
                     DMOB(I,J,K,2) = ZERO
                     DPCNW = ENTRYP(KR)*(-ONE/RPLMDA(KR))
     &                     / (ONE-SWRES(KR))
                     DPC(I,J,K,1) = DPCNW
                     IF (IREFPRES==1) THEN
                        PC(I,J,K,1) = ZERO
                        PC(I,J,K,2) = PCNW
                     ELSE
                        PC(I,J,K,1) = -PCNW
                        PC(I,J,K,2) = ZERO
                     ENDIF
                  ENDIF
               ENDIF

               IF (SNW >= ONE) THEN
                  RELN = KRNW0(KR)
                  PCNW = ZERO
                  IF (AQPHSWTCH) THEN
                     DKNSW = TWO*KRNW0(KR)/(ONE-SORES(KR))
                     DMOB(I,J,K,3) = DKNSW*MOB(I,J,K,3)
                     DMOB(I,J,K,4) = DKNSW*MOB(I,J,K,3)
                     MOB(I,J,K,3) = RELN*MOB(I,J,K,3)
                  ELSE
                     DKNSW = TWO*KRNW0(KR)/(ONE-SWRES(KR))
                     DMOB(I,J,K,2) = DKNSW*MOB(I,J,K,2)
                     MOB(I,J,K,2) = RELN*MOB(I,J,K,2)
                  ENDIF
               ENDIF

            ENDDO
         ENDDO
      ENDDO

      RETURN
      END

C*********************************************************************
      SUBROUTINE XSAT_ERROR(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                      KL2,KEYOUT,NBLK,ERRSAT)
C*********************************************************************

C  ROUTINE DETERMINES MAXIMUM SATURATION ERROR.
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     ERRSAT(I,J,K) = SATURATION ERROR (REAL*8)

C  OUTPUT:
C     SAT_ERRMAX = MAXIMUM ABSOLUTE SATURATION ERROR (REAL*8)
C     ISAT = I LOCATION OF MAXIMUM SATURATION ERROR (INTEGER*4)
C     JSAT = J LOCATION OF MAXIMUM SATURATION ERROR (INTEGER*4)
C     KSAT = K LOCATION OF MAXIMUM SATURATION ERROR (INTEGER*4)
C     NSAT = BLOCK LOCATION OF MAXIMUM SATURATION ERROR (INTEGER*4)

C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xbaldat.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 ERRSAT(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IS,JS,KS,NS
      REAL*8 U,X

      U = -ONE
      DO K = KL1,KL2
         DO  J = JL1V(K),JL2V(K)
            DO  I = IL1,IL2
               IF(KEYOUT(I,J,K) == 1) THEN
                  X = DABS(ERRSAT(I,J,K))
                  IF( X > U) THEN
                     U = X
                     IS = I
                     JS = J
                     KS = K
                     NS = NBLK
                  ENDIF
               ENDIF
            END DO
         END DO
      END DO
      IF(U > SAT_ERRMAX) THEN
         SAT_ERRMAX = U
         ISAT = IS
         JSAT = JS
         KSAT = KS
         NSAT = NBLK
      ENDIF
      END

C*********************************************************************
      SUBROUTINE XSAT_SUMERR(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                       KL2,KEYOUT,NBLK,ERRSAT)
C*********************************************************************

C  ROUTINE DETERMINES SUM OF SATURATION ERRORS.
C  THIS IS A WORK ROUTINE.

C  INPUT:
C     ERRSAT(I,J,K) = SATURATION ERROR (REAL*8)

C  OUTPUT:
C     SAT_ERRAVG = SUM OF ABSOLUTE SATURATION ERRORS (REAL*8)
C     ISAT = I LOCATION OF MAXIMUM SATURATION ERROR (INTEGER*4)
C     JSAT = J LOCATION OF MAXIMUM SATURATION ERROR (INTEGER*4)
C     KSAT = K LOCATION OF MAXIMUM SATURATION ERROR (INTEGER*4)
C     NSAT = BLOCK LOCATION OF MAXIMUM SATURATION ERROR (INTEGER*4)

C***********************************************************************
      IMPLICIT NONE
      INCLUDE 'control.h'
      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'
      INCLUDE 'xbaldat.h'
C-----------------------------------------------------------------------
C     Dummy Arguments
C-----------------------------------------------------------------------
      INTEGER IDIM,JDIM,KDIM,IL1,IL2,KL1,KL2,NBLK,LDIM
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 ERRSAT(IDIM,JDIM,KDIM)
C-----------------------------------------------------------------------
C     Local Variables
C-----------------------------------------------------------------------
      INTEGER I,J,K,IS,JS,KS,NS
      REAL*8 U,X,Y

      U = ZERO
      Y = -ONE
      DO K = KL1,KL2
         DO  J = JL1V(K),JL2V(K)
            DO  I = IL1,IL2
               IF(KEYOUT(I,J,K) == 1) THEN
                  X = DABS(ERRSAT(I,J,K))
                  IF( X > Y) THEN
                     Y = X
                     IS = I
                     JS = J
                     KS = K
                     NS = NBLK
                  ENDIF
                  U = U + X
               ENDIF
            END DO
         END DO
      END DO
      SAT_ERRAVG = U
      IF(Y > SAT_ERRMAX) THEN
         SAT_ERRMAX = Y
         ISAT = IS
         JSAT = JS
         KSAT = KS
         NSAT = NBLK
      ENDIF
      END


C*********************************************************************
      SUBROUTINE XPRES (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                  KL1,KL2,KEYOUT,NBLK,PRES,DELP)
C*********************************************************************

C  UPDATES PRESSURES FOR CELLS.
C  THIS IS A WORK ROUTINE.

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xmodel.h'
      INCLUDE 'control.h'
      INCLUDE 'xiter.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 PRES(IDIM,JDIM,KDIM),DELP(IDIM,JDIM,KDIM)

      INTEGER I,J,K,IPH

      DO K=KL1,KL2
      DO J=JL1V(K),JL2V(K)
      DO I=IL1,IL2
         IF(KEYOUT(I,J,K) == 1) THEN
            PRES(I,J,K) = PRES(I,J,K) + DELP(I,J,K)
         ENDIF
      END DO
      END DO
      END DO

      END

C*********************************************************************
      SUBROUTINE XMFRAC_ALL (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                       KL1,KL2,KEYOUT,NBLK,PMD,MOLFRAC)
C*********************************************************************

C  COMPUTES CURRENT MOLE FRACTION FOR COMPONENTS IN EACH PHASE IPH FROM
C  PMD ARRAY. THIS IS A WORK ROUTINE.

C  PMD(I,J,K,J)= PRODUCT OF MOLAR DENSITY AND MOLE FRACTION (INPUT, REAL*8)

C  MOLFRAC(I,J,K,L)= MOLE FRACTION OF COMPONENT (OUTPUT, REAL*8)

C*********************************************************************
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,KL1,KL2,NBLK,IPH
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 MOLFRAC(IDIM,JDIM,KDIM,NCINPH),PMD(IDIM,JDIM,KDIM,NCINPH)
!     REAL*8  MOLSUM(IDIM,JDIM,KDIM,NPH)
      REAL*8, ALLOCATABLE :: MOLSUM(:,:,:,:)
      INTEGER I,J,K,IC,L,M,IERR

      ALLOCATE(MOLSUM(IDIM,JDIM,KDIM,NPH),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate MOLSUM'

      DO IPH=1,NPH
         DO K = KL1,KL2
            DO J = JL1V(K),JL2V(K)
               DO I = IL1,IL2
                  MOLSUM(I,J,K,IPH) = SMALL
               END DO
            END DO
         END DO
      END DO
      DO IPH=1,NPH
         DO IC = 1,NC
            L = ICINPH(IC,IPH)
            IF(L == 0) CYCLE
            DO K = KL1,KL2
               DO J = JL1V(K),JL2V(K)
                  DO I = IL1,IL2
                     MOLSUM(I,J,K,IPH) = MOLSUM(I,J,K,IPH) +
     &                                   PMD(I,J,K,L)
                  END DO
               END DO
            END DO
         END DO
         DO K = KL1,KL2
            DO J = JL1V(K),JL2V(K)
               DO I = IL1,IL2
                  MOLSUM(I,J,K,IPH) = ONE / MOLSUM(I,J,K,IPH)
               END DO
            END DO
         END DO
         DO IC = 1,NC
            L = ICINPH(IC,IPH)
            IF(L == 0) CYCLE
            DO K = KL1,KL2
               DO J = JL1V(K),JL2V(K)
                  DO I = IL1,IL2
                     MOLFRAC(I,J,K,L) =
     &               PMD(I,J,K,L)*MOLSUM(I,J,K,IPH)
                  END DO
               END DO
            END DO
         END DO
      END DO

      DEALLOCATE(MOLSUM)

      RETURN
      END

C*********************************************************************
      SUBROUTINE XPHMDENS (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                     KL1,KL2,KEYOUT,NBLK,PMD,PHDEN,SAT,DDCOF)
C*********************************************************************
C INPUT:
C     PMD = MOLAR DENSITY * COMPONENT MOLE FRACTION
C     SAT = PHASE SATURATIONS (REAL*8)
C OUTPUT
C     PHDEN = PHASE MOLAR DENSITIES (REAL*8)
C     DDCOF = AVGSAT*AVGDEN AT CELL FACES (REAL*8)
C----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xmodel.h'

      INTEGER I,IC,IL1,IL2,IPH,J,K,IDIM,JDIM,KDIM,LDIM,LC,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 PMD(IDIM,JDIM,KDIM,NCINPH),PHDEN(IDIM,JDIM,KDIM,NPH)
      REAL*8  PHDENAVG,SATAVG,DDCOF(IDIM,JDIM,KDIM,3,NPH),
     &        SAT(IDIM,JDIM,KDIM,NPH)

      DO IPH=1,NPH
         DO K=KL1,KL2
            DO J=JL1V(K),JL2V(K)
               DO I=IL1,IL2
                  PHDEN(I,J,K,IPH)=ZERO
                  IF(KEYOUT(I,J,K) == 0) CYCLE
                  DO IC=1,NC
                     LC=ICINPH(IC,IPH)
                     IF(LC == 0) CYCLE
                     PHDEN(I,J,K,IPH)=PHDEN(I,J,K,IPH)+PMD(I,J,K,LC)
                  END DO

CGUS ---- x-direction
                  IF (KEYOUT(I-1,J,K)/=0) THEN
                  SATAVG = 0.5D0*(SAT(I,J,K,IPH)+SAT(I-1,J,K,IPH))
                  PHDENAVG = 0.5D0*(PHDEN(I,J,K,IPH)+PHDEN(I-1,J,K,IPH))
                  ELSE
                  SATAVG = SAT(I,J,K,IPH)
                  PHDENAVG = PHDEN(I,J,K,IPH)
                  ENDIF
                  DDCOF(I,J,K,1,IPH) = SATAVG*PHDENAVG
CGUS ---- y-direction
                  IF (KEYOUT(I,J-1,K)/=0) THEN
                  SATAVG = 0.5D0*(SAT(I,J,K,IPH)+SAT(I,J-1,K,IPH))
                  PHDENAVG = 0.5D0*(PHDEN(I,J,K,IPH)+PHDEN(I,J-1,K,IPH))
                  ELSE
                  SATAVG = SAT(I,J,K,IPH)
                  PHDENAVG = PHDEN(I,J,K,IPH)
                  ENDIF
                  DDCOF(I,J,K,2,IPH) = SATAVG*PHDENAVG
CGUS ---- z-direction
                  IF (KEYOUT(I,J,K-1)/=0) THEN
                  SATAVG = 0.5D0*(SAT(I,J,K,IPH)+SAT(I,J,K-1,IPH))
                  PHDENAVG = 0.5D0*(PHDEN(I,J,K,IPH)+PHDEN(I,J,K-1,IPH))
                  ELSE
                  SATAVG = SAT(I,J,K,IPH)
                  PHDENAVG = PHDEN(I,J,K,IPH)
                  ENDIF
                  DDCOF(I,J,K,3,IPH) = SATAVG*PHDENAVG

               END DO
            END DO
         END DO
      END DO

      RETURN
      END


C*********************************************************************
      SUBROUTINE XPHDENS (IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &                     KL1,KL2,KEYOUT,NBLK,PMD,PHDEN)
C*********************************************************************
C COMPUTES PHASE MASS DENSITY FROM PRODUCT OF COMPONENT MOLE FRACTIONS
C AND MOLAR DENSITIES
      USE xgendat
      IMPLICIT NONE
      INCLUDE 'xparam.h'
      INCLUDE 'xresprop.h'
      INCLUDE 'xmodel.h'

      INTEGER I,IC,IL1,IL2,IPH,J,K,IDIM,JDIM,KDIM,LDIM,LC,KL1,KL2,NBLK
      INTEGER JL1V(KDIM),JL2V(KDIM),KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 PMD(IDIM,JDIM,KDIM,NCINPH),PHDEN(IDIM,JDIM,KDIM,NPH),MOLWT

      DO IPH=1,NPH
         DO K=KL1,KL2
            DO J=JL1V(K),JL2V(K)
               DO I=IL1,IL2
                  PHDEN(I,J,K,IPH)=ZERO
                  IF(KEYOUT(I,J,K) == 0) CYCLE
                  DO IC=1,NC
                     LC=ICINPH(IC,IPH)
                     IF(LC == 0) CYCLE
                     IF(IC==1) THEN
                        MOLWT=WATMOLW
                     ELSE
                        MOLWT=WMOL(IC-1)
                     ENDIF
                     PHDEN(I,J,K,IPH)=PHDEN(I,J,K,IPH)+
     &                                PMD(I,J,K,LC)*MOLWT
                  END DO
               END DO
            END DO
         END DO
      END DO

      RETURN
      END

C*********************************************************************
      SUBROUTINE XDDINV(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,
     &     KL1,KL2,KEYOUT,NBLK,XC,YC,ZC,XDMAT,DDINV,MPFAQU)
C*********************************************************************
      IMPLICIT NONE

      INCLUDE 'xmodel.h'
C
C DDINV(I,J,K,:,:) = 1/DETB B^T K^{-1} B
C
      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V(KDIM),
     &     JL2V(KDIM),KL1,KL2,KEYOUT(IDIM,JDIM,KDIM),NBLK,
     &     MPFAQU(IDIM,JDIM,KDIM)
      REAL*8  XC(IDIM+1,JDIM+1,KDIM+1),YC(IDIM+1,JDIM+1,KDIM+1),
     &        ZC(IDIM+1,JDIM+1,KDIM+1)
      REAL*8  XDMAT(IDIM,JDIM,KDIM,6,NCINPH)
      REAL*8  DDINV(3,3,8,IDIM,JDIM,KDIM,NCINPH)
C
      INTEGER I,J,K,L,M,N,ROW,COL,IPH,IC,LC
      INTEGER OFFSET(3,8),II,JJ,KK,IPIV(3),INFO
      DATA OFFSET/0,0,0, 1,0,0, 1,1,0, 0,1,0,
     &            0,0,1, 1,0,1, 1,1,1, 0,1,1/
      REAL*8  DD(3,3),DDI(3,3),X(3,8),A(3,3,8)

C------------
C     COMPUTE AND STORE INVERSE OF DIFFUSION DISPERSION TENSOR
C     IN PARTICULAR, EVALUATE TENSOR AT THE 8 CORNERS OF EACH
C     SUB-CUBE PARAMETERIZED BY (I,J,K) AND STORE INVERSE DD TENSOR
C     IN DDI (NOTE, DDI INITIALLY CONTAINS CONTRIBUTIONS FROM
C     DD TENSOR; HERE WE REPLACE ENTRIES WITH CORRESPONDING
C     INVERSE DD VALUES)
C------------

      DDINV = 0.D0

      DO K=KL1,KL2
      DO J=JL1V(K),JL2V(K)
      DO I=IL1,IL2

        IF(KEYOUT(I,J,K)/=0) THEN
        DO N = 1,8
           II = I + OFFSET(1,N)
           JJ = J + OFFSET(2,N)
           KK = K + OFFSET(3,N)
           X(1,N) = XC(II,JJ,KK)
           X(2,N) = YC(II,JJ,KK)
           X(3,N) = ZC(II,JJ,KK)
        ENDDO

        DO IPH=1,NPH
        DO IC=1,NC

          LC=ICINPH(IC,IPH)
          IF(LC == 0) CYCLE

          DD(1,1) = XDMAT(I,J,K,1,LC)
          DD(2,2) = XDMAT(I,J,K,2,LC)
          DD(3,3) = XDMAT(I,J,K,3,LC)
          DD(2,1) = XDMAT(I,J,K,4,LC)
          DD(3,1) = XDMAT(I,J,K,5,LC)
          DD(2,3) = XDMAT(I,J,K,6,LC)
          DD(1,2) = DD(2,1)
          DD(1,3) = DD(3,1)
          DD(3,2) = DD(2,3)

CGUS      BLAS ROUTINE FOR INVERSION (DD^(-1) = DDI)
          CALL GETEYE(DDI,3,3)
          DO ROW = 1,3
             DDI(ROW,ROW) = 1.D0
          ENDDO
          CALL DGESV(3,3,DD,3,IPIV,DDI,3,INFO)
          IF (INFO.NE.0) THEN
             WRITE(*,*)'XDDINV: ERROR BLAS CANNOT INVERT'
             STOP
          ENDIF

          CALL MAPTENSORQUAD(X,DDI,A,MPFAQU(I,J,K))

          DO M=1,8
          DO COL=1,3
          DO ROW=1,3
             DDINV(ROW,COL,M,I,J,K,LC)=A(ROW,COL,M)
          ENDDO
          ENDDO
          ENDDO

        ENDDO
        ENDDO

      ENDIF
      ENDDO
      ENDDO
      ENDDO

      RETURN
      END

C ==================================================================
       SUBROUTINE XVELCOMP(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,JL2V,KL1,
     &                   KL2,KEYOUT,NBLK,TCOFX,TCOFY,TCOFZ,DEPTH,PRES,
     &                   PC,MDEN,MOB,XVEL)
C ------------------------------------------------------------------
C COMPUTES VELOCITIES (FLUXES) ASSOCIATED WITH FACES 1,2,3 (X,Y,Z) OF
C EACH GRIDBLOCK, FOR EACH PHASE 1,2,3 (OIL,WATER,GAS)
C XVEL(I,J,K,IPHASE,1) FOR EXAMPLE CONTAINS THE VALUE OF VELOCITY FOR
C PHASE IPHASE ON THE FACE OF LOCATION I-1/2,J,K.
C-------------------------------------------------------------------
      IMPLICIT NONE
$POWER       INCLUDE 'msjunk.h'

      INCLUDE 'control.h'
      INCLUDE 'layout.h'
      INCLUDE 'xmodel.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,NBLK,KL1,KL2,IDBG1,IDBG2
      INTEGER IERR,JL1,I1,J1,K1,I,J,K,JLP,MKEY1,MKEY
      INTEGER IPHASE,IFACE,MIOFF,MJOFF,MKOFF,IOFF,JOFF,KOFF
      INTEGER OIL,WATER,GAS
      INTEGER JL1V(KDIM),JL2V(KDIM),    KEYOUT(IDIM,JDIM,KDIM)
      REAL*8 G2,DD,DGRAV,DENS1,DENS2,DX,DY,DZ,DP,ZERO
      REAL*8 TCOFX(IDIM,JDIM,KDIM),       TCOFY(IDIM,JDIM,KDIM),
     &       TCOFZ(IDIM,JDIM,KDIM),       DEPTH(IDIM,JDIM,KDIM),
     &       PRES(IDIM,JDIM,KDIM),        PC(IDIM,JDIM,KDIM,NPH),
     &       MDEN(IDIM,JDIM,KDIM,NPH),    MOB(IDIM,JDIM,KDIM,3),
     &       XVEL(IDIM,JDIM,KDIM,NPH,3)

      PARAMETER (IDBG1=102,IDBG2=103,WATER=1,OIL=2,GAS=3,ZERO=0.0D0)

C     GET THE GLOBAL OFFSETS FOR DX,DY,DZ
      CALL BLKOFF(NBLK,IOFF,JOFF,KOFF,IERR)
      IF(IERR.NE.0) RETURN

      G2=.5D0*GRAV

C     MAIN LOOP OVER FACES AND PHASES

      DO IFACE=1,3
         MIOFF=0
         MJOFF=0
         MKOFF=0
         IF (IFACE.EQ.1) MIOFF=1
         IF (IFACE.EQ.2) MJOFF=1
         IF (IFACE.EQ.3) MKOFF=1

      DO IPHASE=1,NPH

      DO K=KL1,KL2+MKOFF
         IF (K.EQ.KL1) THEN
            JL1=JL1V(K)
            JLP=JL2V(K)+MJOFF
         ELSEIF(K.LE.KL2) THEN
            JL1=MIN(JL1V(K-1),JL1V(K))
            JLP=MAX(JL2V(K-1),JL2V(K))+MJOFF
         ELSE
            JL1=JL1V(KL2)
            JLP=JL2V(KL2)
         ENDIF
      DO J=JL1,JLP
      DO I=IL1,IL2+MIOFF

         I1=I-MIOFF
         J1=J-MJOFF
         K1=K-MKOFF

         MKEY=KEYOUT(I,J,K)
         MKEY1=KEYOUT(I1,J1,K1)

C     INNER FACE
         IF(MKEY.EQ.1.AND.MKEY1.EQ.1) GOTO 4
C     GHOST FACE
         IF(((MKEY.EQ.-1).AND.(MKEY1.EQ.1)).OR.
     &      ((MKEY.EQ.1).AND.(MKEY1.EQ.-1))) GOTO 4
C     BDARY FACE: THESE ARE SET TO ZERO AND RECOMPUTED
C     IN BC_VELCOMP
         IF((MKEY.EQ.0.AND.MKEY1.EQ.1).OR.
     &      (MKEY.EQ.1.AND.MKEY1.EQ.0)) GOTO 1
C     ELSE: DO NOT COMPUTE
         GOTO 1

C     BEGINNING OF ACTUAL COMPUTATION FOR XVEL(I,J,K)

 4       CONTINUE
C     DD IS THE DIFFERENCE IN DEPTHS

         DD=(DEPTH(I,J,K)-DEPTH(I1,J1,K1))*G2

C     DP IS DIFFERENCE  OF PRESSURES
C     DP=PPHASE2-PPHASE1

      IF(NPH == 3) THEN
         IF(IREFPRES == WATER) THEN
            IF (IPHASE.EQ.WATER) DP=PRES(I,J,K)-PRES(I1,J1,K1)
            IF (IPHASE.EQ.OIL) DP=PRES(I,J,K)-PRES(I1,J1,K1)
     &               +PC(I,J,K,OIL)-PC(I1,J1,K1,OIL)
            IF (IPHASE.EQ.GAS) DP=PRES(I,J,K)-PRES(I1,J1,K1)
     &               +PC(I,J,K,GAS)-PC(I1,J1,K1,GAS)
         ELSEIF(IREFPRES == OIL) THEN
            IF (IPHASE.EQ.WATER) DP=PRES(I,J,K)-PRES(I1,J1,K1)
     &               +PC(I,J,K,WATER)-PC(I1,J1,K1,WATER)
            IF (IPHASE.EQ.OIL) DP=PRES(I,J,K)-PRES(I1,J1,K1)
            IF (IPHASE.EQ.GAS) DP=PRES(I,J,K)-PRES(I1,J1,K1)
     &               +PC(I,J,K,GAS)-PC(I1,J1,K1,GAS)
         ELSE
            IF (IPHASE.EQ.WATER) DP=PRES(I,J,K)-PRES(I1,J1,K1)
     &               +PC(I,J,K,WATER)-PC(I1,J1,K1,WATER)
            IF (IPHASE.EQ.OIL) DP=PRES(I,J,K)-PRES(I1,J1,K1)
     &               +PC(I,J,K,OIL)-PC(I1,J1,K1,OIL)
            IF (IPHASE.EQ.GAS) DP=PRES(I,J,K)-PRES(I1,J1,K1)
         ENDIF
      ELSEIF(NPH == 2) THEN
         IF(IREFPRES == WATER) THEN
            IF (IPHASE.EQ.WATER) DP=PRES(I,J,K)-PRES(I1,J1,K1)
            IF (IPHASE.EQ.OIL) DP=PRES(I,J,K)-PRES(I1,J1,K1)
     &               +PC(I,J,K,OIL)-PC(I1,J1,K1,OIL)
         ELSE
            IF (IPHASE.EQ.WATER) DP=PRES(I,J,K)-PRES(I1,J1,K1)
     &               +PC(I,J,K,WATER)-PC(I1,J1,K1,WATER)
            IF (IPHASE.EQ.OIL) DP=PRES(I,J,K)-PRES(I1,J1,K1)
         ENDIF
      ELSE
         DP=PRES(I,J,K)-PRES(I1,J1,K1)
      ENDIF

C COMPUTE DGRAV : GRAVITY COMPONENT FROM DARCYS LAW, ASSUME 0.0 FOR
C GAS VELOCITY IF THERE IS NO GAS IN EITHER OF THE CELLS

         DGRAV=0.0D0
         DENS1=MDEN(I1,J1,K1,IPHASE)
         DENS2=MDEN(I,J,K,IPHASE)
         IF (IPHASE.NE.GAS) THEN
            DGRAV=DD*(DENS1+DENS2)
         ELSE
            IF (DENS1.NE.0.0D0.AND.DENS2.NE.0.0D0) THEN
               DGRAV=DD*(DENS1+DENS2)
            ELSE
               IF (DENS1.NE.0.0D0) THEN
                  DGRAV=2.0D0*DD*DENS1
               ENDIF
               IF (DENS2.NE.0.0D0) THEN
                  DGRAV=2.0D0*DD*DENS2
               ENDIF
            ENDIF
         ENDIF
         DP=DP-DGRAV

C DP NOW CONTAINS THE DARCY DIFFERENCES. NOW COMPUTE THE DARCY GRADIENT

         DX=DXREC(I+IOFF,NBLK)
         DY=DYREC(J+JOFF,NBLK)
         DZ=DZREC(K+KOFF,NBLK)

         IF(.NOT.XDARCYFLUX) THEN
            IF(IFACE.EQ.1) DP=-DP*TCOFX(I,J,K)/(DY*DZ)
            IF(IFACE.EQ.2) DP=-DP*TCOFY(I,J,K)/(DX*DZ)
            IF(IFACE.EQ.3) DP=-DP*TCOFZ(I,J,K)/(DX*DY)
         ELSE
            IF(IFACE.EQ.1) DP=-DP*TCOFX(I,J,K)
            IF(IFACE.EQ.2) DP=-DP*TCOFY(I,J,K)
            IF(IFACE.EQ.3) DP=-DP*TCOFZ(I,J,K)
         ENDIF

C COMPUTE VEL=GRADIENT MULTIPLIED BY LAMBDA IN AN UPWINDING WAY

         IF (DP.GT.0.D0) THEN
            IF (IPHASE <= NPH) THEN
               XVEL(I,J,K,IPHASE,IFACE)=DP*MOB(I1,J1,K1,IPHASE)
            ELSE
               STOP 'ERROR IN XVELCOMP: UNDEFINED PHASE NUMBER !!'
            ENDIF
         ELSE
            IF (IPHASE <= NPH) THEN
               XVEL(I,J,K,IPHASE,IFACE)=DP*MOB(I,J,K,IPHASE)
            ELSE
               STOP 'ERROR IN XVELCOMP: UNDEFINED PHASE NUMBER !!'
            ENDIF
         ENDIF

 1       CONTINUE

      ENDDO
      ENDDO
      ENDDO
      ENDDO
      ENDDO

      RETURN
      END

C ==================================================================
       SUBROUTINE XVELCOMP2(IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V,
     &                 JL2V,KL1,KL2,KEYOUT,NBLK,PRES,PC,
     &                 VOLPROP,VOLDIM,FACEPROP,FACEDIM,
     &                 KEYOUTCR,MOBPROD,UPMOBPROD,MOB,
     &                 UPMOB,AINVF,TRAN,XVEL)
C ------------------------------------------------------------------
C COMPUTES VELOCITIES (FLUXES) ASSOCIATED WITH FACES 1,2,3 (X,Y,Z) OF
C EACH GRIDBLOCK, FOR EACH PHASE 1,2,3 (OIL,WATER,GAS)
C XVEL(I,J,K,IPHASE,1) FOR EXAMPLE CONTAINS THE VALUE OF VELOCITY FOR
C PHASE IPHASE ON THE FACE OF LOCATION I-1/2,J,K.
C-------------------------------------------------------------------
      IMPLICIT NONE

      INCLUDE 'xmodel.h'
      INCLUDE 'xparam.h'

      INTEGER IDIM,JDIM,KDIM,LDIM,IL1,IL2,JL1V(KDIM),
     &        JL2V(KDIM),KL1,KL2,KEYOUT(IDIM,JDIM,KDIM),NBLK,
     &        VOLPROP(IDIM+1,JDIM+1,KDIM+1,8),
     &        VOLDIM(IDIM+1,JDIM+1,KDIM+1),
     &        FACEPROP(IDIM+1,JDIM+1,KDIM+1,12),
     &        FACEDIM(IDIM+1,JDIM+1,KDIM+1),
     &        KEYOUTCR(IDIM+1,JDIM+1,KDIM+1)

      REAL*8   PRES(IDIM,JDIM,KDIM),PC(IDIM,JDIM,KDIM,NPH),
     &         AINVF(12,NPH,IDIM+1,JDIM+1,KDIM+1),
     &         TRAN(12,8,IDIM+1,JDIM+1,KDIM+1),
     &         XVEL(IDIM,JDIM,KDIM,NPH,3),
     &         MOBPROD(IDIM,JDIM,KDIM,NCINPH),
     &         UPMOBPROD(IDIM,JDIM,KDIM,3,NCINPH),
     &         MOB(IDIM,JDIM,KDIM,NPH),
     &         UPMOB(IDIM,JDIM,KDIM,NPH,3)

! bag8
      REAL*8, ALLOCATABLE :: VEL(:,:,:,:,:)
! bag8
      REAL*8   PN(8),PIN(8),PCN(8)

      INTEGER I,J,K,M,KR,IPH,IC,LC,DIM,WATER,OIL,GAS,MKEY1,
     &        MKEY,MIOFF,MJOFF,MKOFF,JL1,JLP,I1,J1,K1,
     &        VPROP(8),FPROP(12),IERR

      PARAMETER (WATER=1,OIL=2,GAS=3)

! bag8
      ALLOCATE(VEL(IDIM,JDIM,KDIM,NPH,3),STAT=IERR)
      IF (IERR.NE.0) STOP 'Could not allocate VEL'
! bag8

      VEL       = 0.D0
      UPMOB     = 0.D0
      UPMOBPROD = 0.D0

C ---- VEL CONTAINS ONLY GRAD(P+PC)-RHO*G CONTRIBUTION

      DO K = KL1,KL2+1
      DO J = 1,JDIM+1
      DO I = IL1,IL2+1

         KR = KEYOUTCR(I,J,K)

         DO M = 1,8
            VPROP(M) = VOLPROP(I,J,K,M)
         ENDDO

         DO M = 1,12
            FPROP(M) = FACEPROP(I,J,K,M)
         ENDDO

         IF ((KR.EQ.1).OR.(KR.EQ.2)) THEN

            CALL GETCORNERLOCAL(PN,I,J,K,PRES,IDIM,JDIM,KDIM,
     &                          VPROP)
            DO IPH = 1,NPH
              IF (IPH.EQ.IREFPRES) THEN
                DO M = 1,8
                   PIN(M) = PN(M)
                ENDDO
              ELSE
                CALL GETCORNERLOCAL(PCN,I,J,K,
     &                 PC(1,1,1,IPH),IDIM,JDIM,KDIM,VPROP)
                DO M = 1,8
                   PIN(M) = PN(M) + PCN(M)
                ENDDO
              ENDIF
              CALL VELLOCALUPDATE(VEL(1,1,1,IPH,1),
     &               VEL(1,1,1,IPH,2),VEL(1,1,1,IPH,3),I,J,K,
     &               TRAN(1,1,I,J,K),AINVF(1,IPH,I,J,K),PIN,
     &               VPROP,VOLDIM(I,J,K),FPROP,FACEDIM(I,J,K),
     &               IDIM,JDIM,KDIM,KEYOUT)
            ENDDO

         ENDIF

      ENDDO
      ENDDO
      ENDDO

C ---- CALCULATE XVEL = UPMOB*VEL

      DO DIM = 1,3
        MIOFF = 0
        MJOFF = 0
        MKOFF = 0
      IF (DIM.EQ.1) MIOFF = 1
      IF (DIM.EQ.2) MJOFF = 1
      IF (DIM.EQ.3) MKOFF = 1

      DO IPH = 1,NPH

      DO K=KL1,KL2+MKOFF
         IF (K.EQ.KL1) THEN
            JL1=JL1V(K)
            JLP=JL2V(K)+MJOFF
         ELSEIF(K.LE.KL2) THEN
            JL1=MIN(JL1V(K-1),JL1V(K))
            JLP=MAX(JL2V(K-1),JL2V(K))+MJOFF
         ELSE
            JL1=JL1V(KL2)
            JLP=JL2V(KL2)
         ENDIF
      DO J=JL1,JLP
      DO I=IL1,IL2+MIOFF

         I1=I-MIOFF
         J1=J-MJOFF
         K1=K-MKOFF

         MKEY=KEYOUT(I,J,K)
         MKEY1=KEYOUT(I1,J1,K1)

C     INNER FACE
         IF(MKEY.EQ.1.AND.MKEY1.EQ.1) GOTO 4
C     GHOST FACE
         IF(((MKEY.EQ.-1).AND.(MKEY1.EQ.1)).OR.
     &      ((MKEY.EQ.1).AND.(MKEY1.EQ.-1))) GOTO 4
C     BDARY FACE: THESE ARE SET TO ZERO AND RECOMPUTED
C     IN BC_VELCOMP
         IF((MKEY.EQ.0.AND.MKEY1.EQ.1).OR.
     &      (MKEY.EQ.1.AND.MKEY1.EQ.0)) GOTO 1
C     ELSE: DO NOT COMPUTE
         GOTO 1


C COMPUTE XVEL = MULTIPLY VEL BY LAMBDA IN AN UPWINDING WAY
 4       CONTINUE

      IF (VEL(I,J,K,IPH,DIM)>ZERO) THEN
         XVEL(I,J,K,IPH,DIM) = MOB(I1,J1,K1,IPH)*
     &                 VEL(I,J,K,IPH,DIM)
         UPMOB(I,J,K,IPH,DIM) = MOB(I1,J1,K1,IPH)
         DO IC = 1,NC
            LC = ICINPH(IC,IPH)
            IF (LC==0) CYCLE
            UPMOBPROD(I,J,K,DIM,LC) = MOBPROD(I1,J1,K1,LC)
         ENDDO
      ELSEIF (VEL(I,J,K,IPH,DIM)<ZERO) THEN
         XVEL(I,J,K,IPH,DIM) = MOB(I,J,K,IPH)*
     &                 VEL(I,J,K,IPH,DIM)
         UPMOB(I,J,K,IPH,DIM) = MOB(I,J,K,IPH)
         DO IC = 1,NC
            LC = ICINPH(IC,IPH)
            IF (LC==0) CYCLE
            UPMOBPROD(I,J,K,DIM,LC) = MOBPROD(I,J,K,LC)
         ENDDO
      ELSE
         UPMOB(I,J,K,IPH,DIM) = HALF*(MOB(I,J,K,IPH)
     &                          + MOB(I1,J1,K1,IPH))
         XVEL(I,J,K,IPH,DIM) = UPMOB(I,J,K,IPH,DIM)*
     &                 VEL(I,J,K,IPH,DIM)
         DO IC = 1,NC
            LC = ICINPH(IC,IPH)
            IF (LC==0) CYCLE
            UPMOBPROD(I,J,K,DIM,LC)=HALF*(MOBPROD(I,J,K,LC)
     &                              +MOBPROD(I1,J1,K1,LC))
         ENDDO
      ENDIF

 1       CONTINUE
      ENDDO
      ENDDO
      ENDDO
      ENDDO
      ENDDO

! bag8
      DEALLOCATE(VEL)
! bag8

      RETURN
      END

